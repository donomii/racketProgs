((includes)
 (types)
 (functions

 (list numbers (int num) (declare)
 (body
     (if (greaterthan 0 num)
     (then (return (cons (boxString "-") nil)))
     (else (return (cons (boxString (stringify (boxInt num))) (numbers (sub1 num))))))
 ))

(string lexType (box abox) (declare)
(body
    ;(printf "Comparing %s and %s from %s\n" "\"" (sub-string (stringify abox) 0 1) (stringify abox))
    (if (equalString "string" (boxType abox))
    (then (return "string"))
    (else 
        (if (inList  (boxString (sub-string (stringify abox) 0 1)) (numbers 9))
            (then (return "number"))
            (else (return "symbol")))))
    (return "symbol")
))

  (void perlLeaf (list thisNode int indent) (declare)
   (body 
   (if (equalString "symbol" (lexType (codeof thisNode)))
   (then (printf "%s" "\$" ))
    (else (printf "" ))
   )
(display (perlFuncMap (codeof thisNode)))
   ))

  (void perlStructGetterExpression (list thisNode int indent) (declare)
   (body
    (if (equalBox (boxString "structGetter") (subnameof thisNode))
      (body (perlGetStruct thisNode indent))
      (body (perlLeaf thisNode indent)))))

  (void perlExpression (list node int indent) (declare)
   (body
    (if (isLeaf node)
      (body (perlLeaf node indent))
      (body (perlSubExpression node indent)))))

  (void perlRecurList (list expr int indent) (declare)
   (body
    (if (isEmpty expr)
      (body (return))
      (body
       (perlExpression (car expr) indent)
       (if (isNil (cdr expr))
         (body (printf ""))
         (body (printf ", ") (perlRecurList (cdr expr) indent)))))
    (return)))

  (void perlSubExpression (list tree int indent) (declare (box thing nil))
   (body
    (if (isEmpty tree)
      (body (return))
      (body
       (if (isNode (childrenof tree))
         (body (perlSubExpression (childrenof tree) indent))
         (body
          (if (isLeaf tree)
            (body 
            (printf "%s" "\$")
            (display (perlFuncMap (codeof tree))))
            (body
             (if (equal 1 (listLength (childrenof tree)))
               (body
                (display (codeof (car (childrenof tree))))
                (if (equalBox
                     (boxString "return")
                     (codeof (car (childrenof tree))))
                  (body (printf ""))
                  (body (printf "()"))))
               (body
                (set thing (codeof (car (childrenof tree))))
                (if (equalBox (boxSymbol "get-struct") thing)
                  (body
                   (printf "$%s->{%s}" (stringify (codeof (second (childrenof tree)))) (stringify (codeof (third (childrenof tree))))))
                  (body
                   (if (equalBox (boxSymbol "new") thing)
                     (then
                      (printf "{}"))
                     (else
                      (printf
                       "%s("
                       (stringify
                        (perlFuncMap (codeof (car (childrenof tree))))))
                      (perlRecurList (cdr (childrenof tree)) indent)
                      (printf ")")))))))))))))))

  (void perlIf (list node int indent) (declare)
   (body
    (newLine indent)
    (printf "if ( ")
    (perlExpression (car (first (childrenof node))) 0)
    (printf ") {")
    (perlBody (second (childrenof node)) (add1 indent))
    (newLine indent)
    (printf "} else {")
    (perlBody (third (childrenof node)) (add1 indent))
    (newLine indent)
    (printf "}")))

  (void perlSetStruct (list node int indent)
   (declare)
   (body
    (newLine indent)
    (printf "$%s->{%s} = " (stringify (first (codeof node))) (stringify (second (codeof node))))
    (perlExpression (childrenof node) indent)))

  (void perlGetStruct (list node int indent) (declare)
   (body
    (newLine indent)
    (printf "$%s->{%s}" (stringify (first (codeof node))) (stringify (second (codeof node))))))

  (void perlSet (list node int indent) (declare)
   (body
    (newLine indent)
    (printf "$%s = " (stringify (first (codeof node))))
    (perlExpression (childrenof node) indent)))

  (void perlStatement (list node int indent) (declare)
   (body
    (if (equalBox (boxString "setter") (subnameof node))
      (body (perlSet node indent))
      (body
       (if (equalBox (boxString "structSetter") (subnameof node))
         (body (perlSetStruct node indent))
         (body
          (if (equalBox (boxString "if") (subnameof node))
            (body (perlIf node indent))
            (body
             (if (equalBox (boxString "returnvoid") (subnameof node))
               (body (newLine indent) (printf "return"))
               (body
                (newLine indent)
                (perlExpression (childrenof node) indent)))))))))
    (printf ";\n")))

  (void perlBody (list tree int indent) (declare)
   (body
    (if (isEmpty tree)
      (body (return))
      (body
       (printIndent indent)
       (printf
        "%s"
        "if ($globalStepTrace) {printf(\"StepTrace %s:%d\\n\", __FILE__, __LINE__)}\n")
       (perlStatement (car tree) indent)
       (perlBody (cdr tree) indent)))))
  (void perlDeclarations (list decls int indent) (declare (box decl nil))
   (body
    (if (isEmpty decls)
      (body (return))
      (body
       (set decl (car decls))
       (printf "my \$%s = " (stringify (second decl)))
       (display (perlFuncMap (third decl)))
       (printf ";\n")
       (perlDeclarations (cdr decls) indent)))))

  (void perlFunction (list node) (declare (box name nil) (list noStackTrace nil))
   (body
    (set name (subnameof node))
    (set noStackTrace
     (cons (boxSymbol "troff")
     (cons (boxSymbol "stroff")
     (cons (boxSymbol "stron")
     (cons (boxSymbol "tron")
     (cons (boxSymbol "car")
      (cons (boxSymbol "cdr")
       (cons (boxSymbol "cons")
        (cons (boxSymbol "stackTracePush")
         (cons (boxSymbol "stackTracePop")
          (cons (boxSymbol "assertType")
           (cons (boxSymbol "boxString")
            (cons (boxSymbol "boxInt") nil)))))))))))))
    (printf
     "\n\n#Building function %s from line: %s"
     (stringify name)
     (stringify (getTag name (boxString "line"))))
    (newLine 0)
    (if (isNil node)
      (body (return))
      (body
       (newLine 0)
       (printf "sub %s" (stringify (subnameof node)))
       (printf " {")
       (newLine 1)
       (perlFunctionArgs (cdr (assoc "intype" (cdr node))))
       (newLine 1)
       (perlDeclarations (declarationsof node) 1)
       (printf "\nif ($globalTrace) { printf(\"%s at %s:%s\\n\") }\n" (stringify (subnameof node)) (stringify (getTag name (boxString "filename"))) (stringify (getTag name (boxString "line"))))
       (if (inList name noStackTrace)
         (then (printf ""))
         (else
          (printf
           "\n  stackTracePush(\"%s\", \"%s\", %s, %d );\n"
           (stringify (getTag name (boxString "filename")))
           (stringify (subnameof node))
           (stringify (getTag name (boxString "line")))
           0)))
       (perlBody (childrenof node) 1)
       (if (inList name noStackTrace)
         (then (printf ""))
         (else
          (printf
           "\n  stackTracePop();\nif ($globalTrace) {printf(\"Leaving %s\\n\")}\n"
           (stringify (subnameof node)))))
       (printf "\n}\n")))))

  (void perlForwardDeclaration (list node) (declare)
   (body
    (if (isNil node)
      (body (return))
      (body
       (printf
        "\nsub %s"
        (stringify (subnameof node)))
       (printf ";")))))

  (void perlForwardDeclarations (list tree) (declare)
   (body
    (if (isEmpty tree)
      (body (return))
      (body
       (perlForwardDeclaration (car tree))
       (perlForwardDeclarations (cdr tree))))))

  (void perlFunctions (list tree) (declare)
   (body
    (if (isEmpty tree)
      (body (return))
      (body (perlFunction (car tree)) (perlFunctions (cdr tree))))))
  (void perlIncludes (list nodes) (declare)
   (body
    (printf "%s" " sub greaterthan { \$_[0] > \$_[1] } ; sub equalString { \$_[0] eq \$_[1] } ;sub read_file { my \$file = shift; open my \$fh, '<', \$file or die; local \$/ = undef; my \$cont = <\$fh>; close \$fh; return \$cont; }; ")
    (printf "%s" "sub subtract { \$_[0] - \$_[1]}")))

  (void perlTypeDecl (list l) (declare)
   (body
   (return)
    (if (> (listLength l) 2)
      (body
       (printIndent 1)
       (printf
        "%s %s %s;\n"
        (stringify (second l))
        (stringify (perlTypeMap (last l)))
        (stringify (first l))))
      (body
       (printIndent 1)
       (printf
        "%s %s;\n"
        (stringify (perlTypeMap (last l)))
        (stringify (car l)))))))
  (void
   perlStructComponents
   (list node)
   (declare)
   (body
    (if (isEmpty node)
      (body (return))
      (body (perlTypeDecl (car node)) (perlStructComponents (cdr node))))))

  (void perlStruct (list node) (declare)
   (body (perlStructComponents (cdr (car node))) (return)))

  (box perlTypeMap (box aSym) (declare (list symMap nil))
   (body
    (set
     symMap
     (alistCons
      (boxSymbol "stringArray")
      (boxSymbol "char**")
      (alistCons (boxSymbol "string") (boxSymbol "char*") nil)))
    (if (truthy (assoc (stringify aSym) symMap))
      (body (return (cdr (assoc (stringify aSym) symMap))))
      (body (return aSym)))))

  (box perlFuncMap (box aSym) (declare (list symMap nil))
   (body
    (if (equalString "symbol" (boxType aSym))
      (body
       (set
        symMap
        (alistCons (boxSymbol "sub") (boxSymbol "subtract")
        (alistCons (boxSymbol "=") (boxSymbol "equal")
         (alistCons (boxSymbol "sub-string") (boxSymbol "substr")
          (alistCons (boxSymbol "read-file") (boxSymbol "read_file")
           (alistCons (boxSymbol "write-file") (boxSymbol "write_file")
            (alistCons (boxSymbol ">") (boxSymbol "greaterthan")
             (alistCons (boxSymbol "string-length") (boxSymbol "length")
              (alistCons (boxSymbol "nil") (boxSymbol "undef") nil)))))))))
       (if (truthy (assoc (stringify aSym) symMap))
         (body (return (cdr (assoc (stringify aSym) symMap))))
         (body (return aSym))))
      (body (return aSym)))))

  (void perlType (list node) (declare)
   (body
   (return)
    (if (equalBox (subnameof node) (boxString "struct"))
      (body
       (printf "\ntypedef struct %s {\n" (stringify (first (codeof node))))
       (perlStruct (cdr (codeof node)))
       (printf "\n} %s;\n" (stringify (first (codeof node)))))
      (body (printf "typedef ") (perlTypeDecl (codeof node))))
    (return)))
  (void perlTypes (list nodes) (declare)
   (body
    (if (isEmpty nodes)
      (body (return))
      (body (perlType (car nodes)) (perlTypes (cdr nodes))))))

(void perlFunctionArgs (list tree) (declare)
   (body
    (if (isEmpty tree)
      (body (return))
      (body
       (printf "my \$")
       (display (second tree))
       (printf " = shift;\n")
       (perlFunctionArgs (cddr tree))))))

  (void perlCompile (string filename) (declare (string programStr "") (list tree nil) (list program nil))
   (body
    (set programStr (read-file filename))
    (set tree (readSexpr programStr filename))
    (set
     program
     (alistCons
      (boxString "includes")
      (astIncludes (first tree))
      (alistCons
       (boxString "types")
       (astTypes (second tree))
       (alistCons (boxString "functions") (astFunctions (third tree)) nil))))
    (set program (mergeIncludes program))
    (perlIncludes (cdr (assoc "includes" program)))
    (perlTypes (childrenof (cdr (assoc "types" program))))

    (printf "use strict;\n")
    (printf "my \$globalStackTrace = undef;\n")
    (printf "my \$globalTrace = undef;\n")
    (printf "my \$globalStepTrace = undef;\n")
    (printf "my \$globalArgs = undef;\n")
    (printf "my \$globalArgsCount = undef;\n")
    (printf "my \$true = 1;\n")
    (printf "my \$false = 0;\n")
    (printf "my \$undef;\n")
    (printf
     "\nsub isNil {\n    return defined($_[0]);\n}\n\n\n#Forward declarations\n")
    (perlForwardDeclarations
     (cdr (assoc "children" (cdr (cdr (assoc "functions" program))))))
    (printf "\n\n#End forward declarations\n\n")
    (perlFunctions
     (cdr (assoc "children" (cdr (cdr (assoc "functions" program))))))
    (printf ";\n")
    (printf "start();")
    ))

  )
