((includes)
 (types
  (Box
   (struct
    (lis struct Box*)
    (str string)
    (i int)
    (typ string)
    (voi bool)
    (boo bool)
    (lengt int)
    (car struct Box*)
    (cdr struct Box*)
    (tag struct Box*)))
  (box Box*)
  (Pair Box)
  (pair Box*)
  (list Box*))
 (functions
  (int add (int a int b) (declare) (body (return (sub a (sub 0 b)))))
  (float addf (float a float b) (declare) (body (return (subf a (subf 0 b)))))
  (int sub1 (int a) (declare) (body (return (sub a 1))))
  (int add1 (int a) (declare) (body (return (add a 1))))
  (box
   clone
   (box b)
   (declare (box newb nil))
   (body
    (set newb (new newb Box))
    (set-struct newb typ (get-struct b typ))
    (set-struct newb lis (get-struct b lis))
    (set-struct newb str (get-struct b str))
    (set-struct newb i (get-struct b i))
    (set-struct newb lengt (get-struct b lengt))
    (return newb)))
  (box
   newVoid
   ()
   (declare (box newb nil))
   (body
    (set newb (new newb Box))
    (set-struct newb voi true)
    (set-struct newb typ "void")
    (return newb)))
  (list cons (box data list l) (declare (pair p nil))
   (body
    (set p (new pair Pair))
    (set-struct p cdr l)
    (set-struct p car data)
    (set-struct p typ "list")
    (return p)))

  (void stackDump () (declare) (body (display globalStackTrace)))
  (box
   car
   (list l)
   (declare)
   (body
    (assertType "list" l)
    (if (isNil l)
      (body
       (printf "Cannot call car on empty list!\n")
       (panic "Cannot call car on empty list!\n")
       (return nil))
      (body
       (if (isNil (get-struct l car))
         (body (return nil))
         (body (return (get-struct l car))))))))
  (list
   cdr
   (list l)
   (declare)
   (body
    (assertType "list" l)
    (if (isEmpty l)
      (body
       (printf "Attempt to cdr an empty list!!!!\n")
       (panic "Attempt to cdr an empty list!!!!\n")
       (return nil))
      (body (return (get-struct l cdr))))))
  (bool
   isList
   (box b)
   (declare)
   (body
    (if (isNil b)
      (body (return true))
      (body (return (equalString "list" (get-struct b typ)))))))
  (list emptyList () (declare) (body (return nil)))
  (bool
   isEmpty
   (box b)
   (declare)
   (body
    (if (isNil b)
      (body (return true))
      (body (if (isList b) (body (return false)) (body (return false)))))))
  (list
   alistCons
   (box key box value list alist)
   (declare)
   (body (return (cons (cons key value) alist))))

  (list assoc (string searchTerm list l) (declare (list elem nil))
   (body
    (assertType "list" l)
    (if (isEmpty l)
      (body (return (boxBool false)))
      (body
       (set elem (car l))
       (assertType "list" elem)
       (if (isEmpty elem)
         (body (return (assoc searchTerm (cdr l))))
         (body
          (if (equalString
               searchTerm
               (stringify (car elem)))
            (body (return elem))
            (body (return (assoc searchTerm (cdr l)))))))))))

  (bool equalBox (box a box b) (declare)
   (body
    (if (isList b)
      (body (return false))
      (body
       (if (equalString "string" (boxType a))
         (body (return (equalString (unBoxString a) (stringify b))))
         (body
          (if (equalString "bool" (boxType a))
            (body (return (andBool (unBoxBool a) (unBoxBool b))))
            (body
             (if (equalString "symbol" (boxType a))
               (body
                (if (equalString "symbol" (boxType b))
                  (body (return (equalString (unBoxSymbol a) (unBoxSymbol b))))
                  (body (return false))))
               (body
                (if (equalString "int" (boxType a))
                  (body (return (equal (unBoxInt a) (unBoxInt b))))
                  (body (return false)))))))))))))
(void
   displayList
   (list l int indent)
   (declare (box val nil))
   (body
    (if (isEmpty l)
      (body (return))
      (body
       (if (isList l)
         (body
          (if (isEmpty l)
            (body (return))
            (body
             (set val (car l))
             (if (isList val)
               (body
                (newLine indent)
                (printf "%s" (openBrace))
                (displayList (car l) (add1 indent))
                (printf "%s" (closeBrace))
                (displayList (cdr l) (add1 indent)))
               (body
                (if (equalString "string" (get-struct val typ))
                  (body (printf "\"%s\" " (unBoxString val)))
                  (body (printf "%s " (stringify val))))
                (displayList (cdr l) indent))))))
         (body
          (if (equalString "string" (get-struct l typ))
            (body (printf "\"%s\" " (unBoxString l)))
            (body (printf "%s " (stringify l))))))))))
  (void
   display
   (list l)
   (declare)
   (body
    (if (isEmpty l)
      (body (printf "nil ") (return))
      (body
       (if (isList l)
         (body (printf "[") (displayList l 0) (printf "]"))
         (body (displayList l 0)))))))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; Types and type converters ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (string boxType (box b) (declare) (body (return (get-struct b typ))))
  (box
   boxString
   (string s)
   (declare (box b nil))
   (body
    (set b (new box Box))
    (set-struct b str s)
    (set-struct b lengt (string-length s))
    (set-struct b typ "string")
    (return b)))
  (box
   boxSymbol
   (string s)
   (declare (box b nil))
   (body (set b (boxString s)) (set-struct b typ "symbol") (return b)))
  (box
   boxBool
   (bool boo)
   (declare (box b nil))
   (body
    (set b (new box Box))
    (set-struct b boo boo)
    (set-struct b typ "bool")
    (return b)))
  (box
   boxInt
   (int val)
   (declare (box b nil))
   (body
    (set b (new box Box))
    (set-struct b i val)
    (set-struct b typ "int")
    (return b)))
  (void
   assertType
   (string atype box abox)
   (declare)
   (body
    (if (isNil abox)
      (body (if (equalString atype "nil") (body (return)) (body (return))))
      (body
       (if (equalString atype (boxType abox))
         (body (return))
         (body
          (printf
           "Assertion failure: provided value is not a '%s'!  It was actually:"
           atype)
          (display abox)
          (panic "Invalid type!")))))))
  (string unBoxString (box b) (declare)
   (body (assertType "string" b) (return (get-struct b str))))

  (string unBoxSymbol (box b) (declare) (body (return (get-struct b str))))
  (bool unBoxBool (box b) (declare) (body (return (get-struct b boo))))
  (int unBoxInt (box b) (declare) (body (return (get-struct b i))))

  (string stringify (box b) (declare)
   (body
    (if (isNil b)
      (body (return "nil"))
      (body
       (if (equalString "string" (boxType b))
         (body (return (unBoxString b)))
         (body
          (if (equalString "bool" (boxType b))
            (body
             (if (unBoxBool b) (body (return "true")) (body (return "false"))))
            (body
             (if (equalString "int" (boxType b))
               (then (return (intToString (unBoxInt b))))
               (else
                (if (equalString "symbol" (boxType b))
                  (body (return (unBoxSymbol b)))
                  (body (return (boxType b))))))))))))))
  ;;;;;;;;;;;;;;;;;;
  ;; Tag functions
  ;;;;;;;;;;;;;;;;;;

  (bool
   hasTag
   (box aBox box key)
   (declare)
   (body
    (if (isNil aBox)
      (then (return false))
      (else (return (truthy (assoc (stringify key) (get-struct aBox tag))))))))
  (box
   getTag
   (box aBox box key)
   (declare)
   (body (return (cdr (assoc (stringify key) (get-struct aBox tag))))))
  (box
   getTagFail
   (box aBox box key box onFail)
   (declare)
   (body
    (if (hasTag aBox key)
      (then (return (cdr (assoc (stringify key) (get-struct aBox tag)))))
      (else (return onFail)))))
  (box
   setTag
   (box aStruct box key list val)
   (declare)
   (body
    (set-struct aStruct tag (alistCons key val (get-struct aStruct tag)))
    (return aStruct)))
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; Parser functions
  ;;;;;;;;;;;;;;;;;;;;;;;

    (list
   filterVoid
   (list l)
   (declare (box token nil))
   (body
    (if (isEmpty l)
      (body (return (emptyList)))
      (body
       (set token (car l))
       (if (equalString "void" (get-struct token typ))
         (body (return (filterVoid (cdr l))))
         (body (return (cons token (filterVoid (cdr l))))))))))
  (list
   filterTokens
   (list l)
   (declare (box token nil))
   (body
    (if (isEmpty l)
      (body (return (emptyList)))
      (body
       (set token (car l))
       (if (equalString (boxType token) "symbol")
         (then
          (if (equalString "__LINE__" (stringify token))
            (then
             (return
              (cons
               (getTagFail token (boxString "line") (boxInt -1))
               (filterTokens (cdr l)))))
            (else
             (if (equalString "__COLUMN__" (stringify token))
               (then
                (return
                 (cons
                  (getTagFail token (boxString "column") (boxInt -1))
                  (filterTokens (cdr l)))))
               (else (return (cons token (filterTokens (cdr l)))))))))
         (else (return (cons token (filterTokens (cdr l))))))))))
  (box
   finish_token
   (string prog int start int len int line int column string filename)
   (declare (box token nil))
   (body
    (if (> len 0)
      (body
       (set token (boxSymbol (sub-string prog start len)))
       (set-struct
        token
        tag
        (alistCons
         (boxString "filename")
         (boxString filename)
         (alistCons
          (boxString "column")
          (boxInt column)
          (alistCons
           (boxString "line")
           (boxInt line)
           (alistCons (boxString "totalCharPos") (boxInt start) nil)))))
       (return token))
      (body (return (newVoid))))))
  (string
   readString
   (string prog int start int len)
   (declare (string token ""))
   (body
    (set token (sub-string prog (sub1 (add start len)) 1))
    (if (equalString "\"" token)
      (body (return (sub-string prog start (sub1 len))))
      (body
       (if (equalString "\\" token)
         (body (return (readString prog start (add 2 len))))
         (body (return (readString prog start (add1 len)))))
       (return (readString prog start (add1 len)))))))
  (string
   readComment
   (string prog int start int len)
   (declare (string token ""))
   (body
    (set token (sub-string prog (sub1 (add start len)) 1))
    (if (isLineBreak token)
      (body (return (sub-string prog start (sub1 len))))
      (body (return (readComment prog start (add1 len)))))))
  (bool
   isWhiteSpace
   (string s)
   (declare)
   (body
    (if (equalString " " s)
      (then (return true))
      (else
       (if (equalString "\n" s)
         (then (return true))
         (else
          (if (equalString "\r" s)
            (then (return true))
            (else (return false)))))))))
  (bool
   isLineBreak
   (string s)
   (declare)
   (body
    (if (equalString "\n" s)
      (then (return true))
      (else
       (if (equalString "\r" s) (then (return true)) (else (return false)))))))
  (int
   incForNewLine
   (box token int val)
   (declare)
   (body
    (if (equalString "\n" (stringify token))
      (then (return (add1 val)))
      (else (return val)))))

  (list scan (string prog int start int len int linecount int column string filename) (declare (box token nil))
   (body
   ;(printf "Scanning: line %d:%d\n" start len)
    (if (> (string-length prog) (sub start (sub 0 len)))
      (body
       (set token (boxSymbol (sub-string prog (sub1 (add start len)) 1)))
       (set-struct token tag (alistCons (boxString "totalCharPos") (boxInt start) nil))
       (if (isOpenBrace token)
         (then
          (return (cons (finish_token prog start (sub1 len) linecount column filename) (cons (boxSymbol (openBrace))
             (scan prog (add1 start) 1 linecount (add1 column) filename)))))
         (else
          (if (isCloseBrace token)
            (then
             (return
              (cons (finish_token prog start (sub1 len) linecount column filename)
               (cons (boxSymbol (closeBrace))
                (scan prog (add start len) 1 linecount (add1 column) filename)))))
            (else
             (if (isWhiteSpace (stringify token))
               (body
                (return
                 (cons
                  (finish_token
                   prog
                   start
                   (sub1 len)
                   linecount
                   column
                   filename)
                  (scan
                   prog
                   (add start len)
                   1
                   (incForNewLine token linecount)
                   0
                   filename))))
               (body
                (if (equalBox (boxSymbol ";") token)
                  (then
                   (return (scan prog (add start (add1 (add1 (string-length (readComment prog (add1 start) len)))))
                     1
                     (add1 linecount)
                     0
                     filename)))
                  (body
                   (if (equalBox (boxSymbol "\"") token)
                     (body
                      (return
                       (cons
                        (boxString (readString prog (add1 start) len))
                        (scan
                         prog
                         (add
                          start
                          (add1
                           (add1
                            (string-length
                             (readString prog (add1 start) len)))))
                         1
                         linecount
                         (add1 column)
                         filename))))
                     (body
                      (return (scan prog start (sub len -1) linecount (add1 column) filename)))))))))))))
      (body (return (emptyList))))
    (return (emptyList))))

  (bool
   isOpenBrace
   (box b)
   (declare)
   (body
    (if (equalBox (boxSymbol (openBrace)) b)
      (body (return true))
      (body
       (if (equalBox (boxSymbol "[") b)
         (body (return true))
         (body (return false)))))))
  (string openBrace () (declare) (body (return "(")))
  (bool
   isCloseBrace
   (box b)
   (declare)
   (body
    (if (equalBox (boxSymbol (closeBrace)) b)
      (body (return true))
      (body
       (if (equalBox (boxSymbol "]") b)
         (body (return true))
         (body (return false)))))))
  (string closeBrace () (declare) (body (return ")")))
  (list
   sexprTree
   (list l)
   (declare (box b nil))
   (body
    (if (isEmpty l)
      (body (return (emptyList)))
      (body
       (set b (car l))
       (if (isOpenBrace b)
         (then
          (return (cons (sexprTree (cdr l)) (sexprTree (skipList (cdr l))))))
         (else
          (if (isCloseBrace b)
            (body (return (emptyList)))
            (body
             (return
              (setTag
               (cons b (sexprTree (cdr l)))
               (boxString "line")
               (getTagFail b (boxString "line") (boxInt -1))))))))))
    (printf "AAAAAA code should never reach here!\n")
    (return (emptyList))))

  (list
   skipList
   (list l)
   (declare (box b nil))
   (body
    (if (isEmpty l)
      (body (return (emptyList)))
      (body
       (set b (car l))
       (if (isOpenBrace b)
         (body (return (skipList (skipList (cdr l)))))
         (body
          (if (isCloseBrace b)
            (body (return (cdr l)))
            (body (return (skipList (cdr l)))))))))
    (printf "AAAAAA code should never reach here!\n")
    (return (emptyList))))
  (list
   readSexpr
   (string aStr string filename)
   (declare (list tokens nil) (list as nil))
   (body
    (set tokens (emptyList))
    (set tokens (filterTokens (filterVoid (scan aStr 0 1 0 0 filename))))
    (set as (sexprTree tokens))
    (return (car as))))


  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; Power on self tests
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (void
   test0
   ()
   (declare)
   (body
    (if (equalString
         (stringify (boxString "hello"))
         (stringify (boxString "hello")))
      (body (printf "0.  pass string compare works\n"))
      (body (printf "0.  pass string compare fails\n")))
    (if (equalString
         (stringify (boxString "hello"))
         (stringify (boxSymbol "hello")))
      (body (printf "0.  pass string compare works\n"))
      (body (printf "0.  pass string compare fails\n")))))
  (void
   test1
   ()
   (declare)
   (body (printf "1.  pass Function call and print work\n")))
  (void
   test2_do
   (string message)
   (declare)
   (body (printf "2.  pass Function call with arg works: %s\n" message)))
  (void test2 () (declare) (body (test2_do "This is the argument")))
  (void
   test3_do
   (int b string c)
   (declare)
   (body
    (printf "3.1 pass Two arg call, first arg: %d\n" b)
    (printf "3.2 pass Two arg call, second arg: %s\n" c)))
  (void test3 () (declare) (body (test3_do 42 "Fourty-two")))
  (string test4_do () (declare) (body (return "pass Return works")))
  (string
   returnThis
   (string returnMessage)
   (declare)
   (body (return returnMessage)))
  (void
   test4
   ()
   (declare (string message "fail"))
   (body (set message (test4_do)) (printf "4.  %s\n" message)))
  (void
   test5
   ()
   (declare (string message "fail"))
   (body
    (set message (returnThis "pass return passthrough string"))
    (printf "5.  %s\n" message)))
  (void
   test6
   ()
   (declare)
   (body
    (if true
      (body (printf "6.  pass If statement works\n"))
      (body (printf "6.  fail If statement works\n")))))
  (int
   test7_do
   (int count)
   (declare)
   (body
    (set count (sub count 1))
    (if (> count 0) (body (set count (test7_do count))) (body (return count)))
    (return count)))
  (void
   test7
   ()
   (declare)
   (body
    (if (= 0 (test7_do 10))
      (body (printf "7.  pass count works\n"))
      (body (printf "7.  fail count fails\n")))))
  (void
   beer
   ()
   (declare)
   (body
    (printf
     "%d bottle of beer on the wall, %d bottle of beer.  Take one down, pass it round, no bottles of beer on the wall\n"
     1
     1)))
  (string
   plural
   (int num)
   (declare)
   (body (if (equal num 1) (body (return "")) (body (return "s")))))
  (int
   beers
   (int count)
   (declare (int newcount 0))
   (body
    (set newcount (sub count 1))
    (printf
     "%d bottle%s of beer on the wall, %d bottle%s of beer.  Take one down, pass it round, %d bottle%s of beer on the wall\n"
     count
     (plural count)
     count
     (plural count)
     newcount
     (plural newcount))
    (if (> count 1) (body (set count (beers newcount))) (body (return count)))
    (return 0)))
  (void
   test8
   ()
   (declare)
   (body
    (if (equal (sub (sub 2 1) (sub 3 1)) -1)
      (body (printf "8.  pass Nested expressions work\n"))
      (body (printf "8.  fail Nested expressions don't work\n")))))
  (void
   test9
   ()
   (declare (int answer -999999))
   (body
    (set answer (sub (sub 20 1) (sub 3 1)))
    (if (equal answer 17)
      (body (printf "9.  pass arithmetic works\n"))
      (body (printf "9.  fail arithmetic\n")))))
  (void
   test10
   ()
   (declare (string testString "This is a test string"))
   (body
    (if (equalString
         testString
         (unBoxString (car (cons (boxString testString) nil))))
      (body (printf "10. pass cons and car work\n"))
      (body (printf "10. fail cons and car fail\n")))))
  (void
   test12
   ()
   (declare (box b nil))
   (body
    (set b (new box Box))
    (set-struct b str "12. pass structure accessors\n")
    (printf "%s" (get-struct b str))))
  (void
   test13
   ()
   (declare
    (string testString "Hello from the filesystem!")
    (string contents ""))
   (body
    (write-file "test.txt" testString)
    (set contents (read-file "test.txt"))
    (if (equalString testString contents)
      (body (printf "13. pass Read and write files\n"))
      (body (printf "13. fail Read and write files\n")))))
(void
   test15
   ()
   (declare (string a "hello") (string b " world") (string c ""))
   (body
    (set c (stringConcatenate a b))
    (if (equalString c "hello world")
      (body (printf "15. pass String concatenate\n"))
      (body (printf "15. fail String concatenate\n")))))

  (void
   test16
   ()
   (declare
    (list assocCell1 nil)
    (list assList nil)
    (list assocCell2 nil)
    (list assocCell3 nil))
   (body
    (set assocCell1 (cons (boxString "Hello") (boxString "world")))
    (set assocCell2 (cons (boxString "goodnight") (boxString "moon")))
    (set assocCell3 (cons (boxSymbol "ohio") (boxString "gozaimasu")))
    (set assList (cons assocCell2 (emptyList)))
    (set assList (cons assocCell1 assList))
    (set assList (cons assocCell3 assList))
    (if (equalBox (cdr (assoc "Hello" assList)) (boxString "world"))
      (body (printf "16.1 pass Basic assoc works\n"))
      (body (printf "16.1 fail Basic assoc fails\n")))
    (if (andBool
         (andBool
          (equalBox (cdr (assoc "Hello" assList)) (boxString "world"))
          (equalBox (cdr (assoc "goodnight" assList)) (boxString "moon")))
         (equalBox (cdr (assoc "ohio" assList)) (boxString "gozaimasu")))
      (body (printf "16.2 pass assoc list\n"))
      (body (printf "16.2 fail assoc list\n")))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; List access functions ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (box caar (list l) (declare) (body (return (car (car l)))))
  (box cadr (list l) (declare) (body (return (car (cdr l)))))
  (box caddr (list l) (declare) (body (return (car (cdr (cdr l))))))
  (box cadddr (list l) (declare) (body (return (car (cdr (cdr (cdr l)))))))
  (box
   caddddr
   (list l)
   (declare)
   (body (return (car (cdr (cdr (cdr (cdr l))))))))
  (box cddr (list l) (declare) (body (return (cdr (cdr l)))))
  (box first (list l) (declare) (body (return (car l))))
  (box second (list l) (declare) (body (return (cadr l))))
  (box third (list l) (declare) (body (return (caddr l))))
  (box fourth (list l) (declare) (body (return (cadddr l))))
  (box fifth (list l) (declare) (body (return (caddddr l))))

;;;;;;;;;;;;;;;;;;;;;;
;; Parser functions ;;
;;;;;;;;;;;;;;;;;;;;;;

  (list makeNode (string name string subname list code list children) (declare)
   (body
    (return
     (cons
      (boxSymbol "node")
      (alistCons
       (boxSymbol "line")
       (getTagFail code (boxString "line") (boxInt -1))
       (cons
        (cons (boxSymbol "name") (boxString name))
        (cons
         (cons (boxSymbol "subname") (boxString subname))
         (cons
          (cons (boxSymbol "code") code)
          (alistCons (boxSymbol "children") children (emptyList))))))))))

(list addToNode (box key box val list node) (declare)
(body
(return (cons (boxSymbol "node") (alistCons key val (cdr node))))
))

  (list makeStatementNode (string name string subname list code list children box functionName) (declare)
(body
    (return (addToNode (boxSymbol "functionName") functionName (makeNode name subname code children)))
))

  (list
   astExpression
   (list tree)
   (declare)
   (body
    (if (isList tree)
      (body
       (return
        (makeNode "expression" "expression" nil (astSubExpression tree))))
      (body (return (astSubExpression tree))))))
  (list
   astSubExpression
   (list tree)
   (declare)
   (body
    (if (isEmpty tree)
      (body (return (emptyList)))
      (body
       (if (isList tree)
         (body
          (return
           (cons (astExpression (car tree)) (astSubExpression (cdr tree)))))
         (body (return (makeNode "expression" "leaf" tree nil))))))))

  (list astIf (list tree box fname) (declare)
   (body
    (return
     (makeNode "statement" "if" tree 
        (cons
           (cons (astExpression (first tree)) nil)
           (cons
            (astBody (cdr (second tree)) fname)
            (cons (astBody (cdr (third tree)) fname) nil)))))))

  (list
   astSetStruct
   (list tree)
   (declare)
   (body
    (return
     (makeNode "statement" "structSetter" tree (astExpression (third tree))))))
  (list
   astSet
   (list tree)
   (declare)
   (body
    (return
     (makeNode "statement" "setter" tree (astExpression (second tree))))))
  (list
   astGetStruct
   (list tree)
   (declare)
   (body (return (makeNode "expression" "structGetter" tree nil))))

  (list astReturnVoid (box fname)
   (declare)
   (body (return (makeStatementNode "statement" "returnvoid" nil nil fname))))

  (int listLength
   (list l)
   (declare)
   (body
    (if (isEmpty l)
      (body (return 0))
      (body (return (add1 (listLength (cdr l))))))))

  (list astStatement (list tree box fname) (declare)
   (body
    (if (equalBox (boxString "if") (car tree))
      (then (return (astIf (cdr tree) fname)))
      (else
       (if (equalBox (boxString "set") (car tree))
         (then (return (astSet (cdr tree))))
         (else
          (if (equalBox (boxString "get-struct") (car tree))
            (then
             (printf "Choosing get-struct statement\n")
             (return (astGetStruct (cdr tree))))
            (else
             (if (equalBox (boxString "set-struct") (car tree))
               (then (return (astSetStruct (cdr tree))))
               (else
                   (if (equalBox  (boxString "return") (car tree))
                   (then
                        (if (equal (listLength tree) 1)
                        (then (return (astReturnVoid fname)))
                        (else
                          (return
                           (makeStatementNode "statement" "return" tree
                            (makeNode "expression" "expression" tree (astExpression tree)) fname )))))
                  (else
                   (return 
                    (makeStatementNode 
                       "statement" "statement" tree
                         (makeNode "expression" "expression" tree (astExpression tree) ) fname ))))))))))))))

  (list astBody (list tree box fname) (declare)
   (body
    (if (isEmpty tree)
      (then (return (emptyList)))
      (else (return (cons (astStatement (car tree) fname) (astBody (cdr tree) fname)))))))

  (list
   astFunction
   (list tree)
   (declare (box fname nil))
   (body
    (set fname (second tree))
    (return
     (alistCons
      (boxSymbol "line")
      (getTag fname (boxString "line"))
      (cons
       (cons (boxSymbol "name") (boxString "function"))
       (cons
        (cons (boxSymbol "subname") (second tree))
        (cons
         (cons (boxSymbol "declarations") (cdr (fourth tree)))
         (cons
          (cons (boxSymbol "intype") (third tree))
          (cons
           (cons (boxSymbol "outtype") (car tree))
           (cons
            (cons (boxSymbol "children") (astBody (cdr (fifth tree)) fname))
            (emptyList)))))))))))
  (list
   astFunctionList
   (list tree)
   (declare)
   (body
    (if (isEmpty tree)
      (body (return (emptyList)))
      (body
       (return
        (cons (astFunction (car tree)) (astFunctionList (cdr tree))))))))
  (list
   astFunctions
   (list tree)
   (declare)
   (body
    (return
     (makeNode "functions" "functions" tree (astFunctionList (cdr tree))))))
  (list
   loadLib
   (string path)
   (declare (string programStr "") (list tree nil) (list library nil))
   (body
    ;(printf "//Loading library %s\n" path)
    (set programStr (read-file path))
    (set tree (readSexpr programStr path))
    (set
     library
     (alistCons
      (boxString "includes")
      (astIncludes (first tree))
      (alistCons
       (boxString "types")
       (astTypes (second tree))
       (alistCons (boxString "functions") (astFunctions (third tree)) nil))))
    (return library)))
  (list
   astInclude
   (list tree)
   (declare)
   (body (return (loadLib (stringify tree)))))
  (list
   astIncludeList
   (list tree)
   (declare)
   (body
    (if (isEmpty tree)
      (body (return (emptyList)))
      (body
       (return (cons (astInclude (car tree)) (astIncludeList (cdr tree))))))))
  (list
   astIncludes
   (list tree)
   (declare)
   (body
    ;(printf "//Building includes AST...\n")
    (return
     (makeNode "includes" "includes" tree (astIncludeList (cdr tree))))))
  (list
   astStruct
   (list tree)
   (declare)
   (body (return (makeNode "type" "struct" tree nil))))
  (list
   astType
   (list tree)
   (declare)
   (body
    (if (isList (cadr tree))
      (body (return (astStruct tree)))
      (body (return (makeNode "type" "type" tree nil))))))
  (list
   astTypeList
   (list tree)
   (declare)
   (body
    (if (isEmpty tree)
      (body (return (emptyList)))
      (body (return (cons (astType (car tree)) (astTypeList (cdr tree))))))))
  (list
   astTypes
   (list tree)
   (declare)
   (body (return (makeNode "types" "types" tree (astTypeList (cdr tree))))))

  (void ansiFunctionArgs (list tree) (declare)
   (body
    (if (isEmpty tree)
      (body (return))
      (body
       (display (ansiTypeMap (first tree)))
       (display (second tree))
       (if (isNil (cddr tree)) (body (printf "")) (body (printf ",")))
       (ansiFunctionArgs (cddr tree))))))

  (list
   declarationsof
   (list ass)
   (declare)
   (body (return (cdr (assoc "declarations" (cdr ass))))))

  (list codeof (list ass) (declare)
   (body (return (cdr (assoc "code" (cdr ass))))))

  (list functionNameof (list ass) (declare)
   (body (return (cdr (assoc "functionName" (cdr ass))))))

  (list
   nodeof
   (list ass)
   (declare)
   (body
    (if (equalBox (boxBool false) (assoc "node" (cdr ass)))
      (body (return (boxBool false)))
      (body (return (cdr (assoc "node" (cdr ass))))))))
  (list
   lineof
   (list ass)
   (declare)
   (body
    (if (equalBox (boxBool false) (assoc "line" (cdr ass)))
      (body (return (boxInt -1)))
      (body (return (cdr (assoc "line" (cdr ass))))))))
  (list
   subnameof
   (list ass)
   (declare)
   (body (return (cdr (assoc "subname" (cdr ass))))))
  (list
   nameof
   (list ass)
   (declare)
   (body (return (cdr (assoc "name" (cdr ass))))))

  (list childrenof (list ass) (declare)
   (body (return (cdr (assoc "children" (cdr ass))))))

  (bool
   isNode
   (list val)
   (declare)
   (body
    (if (isEmpty val)
      (body (return false))
      (body
       (if (isList val)
         (body
          (if (equalBox (boxSymbol "node") (car val))
            (body (return true))
            (body (return false))))
         (body (return false)))))))

  (bool
   truthy
   (box aVal)
   (declare)
   (body
    (if (equalBox (boxBool false) aVal)
      (body (return false))
      (body (return true)))))
  (void
   ansiLeaf
   (list thisNode int indent)
   (declare)
   (body (display (ansiFuncMap (codeof thisNode)))))
  (void
   ansiStructGetterExpression
   (list thisNode int indent)
   (declare)
   (body
    (if (equalBox (boxString "structGetter") (subnameof thisNode))
      (body (ansiGetStruct thisNode indent))
      (body (ansiLeaf thisNode indent)))))
  (void
   ansiExpression
   (list node int indent)
   (declare)
   (body
    (if (isLeaf node)
      (body (display (ansiFuncMap (codeof node))))
      (body (ansiSubExpression node indent)))))
  (void
   ansiRecurList
   (list expr int indent)
   (declare)
   (body
    (if (isEmpty expr)
      (body (return))
      (body
       (ansiExpression (car expr) indent)
       (if (isNil (cdr expr))
         (body (printf ""))
         (body (printf ", ") (ansiRecurList (cdr expr) indent)))))
    (return)))
  (bool
   isLeaf
   (list n)
   (declare)
   (body (return (equalBox (boxString "leaf") (subnameof n)))))
  (void
   ansiSubExpression
   (list tree int indent)
   (declare (box thing nil))
   (body
    (if (isEmpty tree)
      (body (return))
      (body
       (if (isNode (childrenof tree))
         (body (ansiSubExpression (childrenof tree) indent))
         (body
          (if (isLeaf tree)
            (body (display (ansiFuncMap (codeof tree))))
            (body
             (if (equal 1 (listLength (childrenof tree)))
               (body
                (display (codeof (car (childrenof tree))))
                (if (equalBox
                     (boxString "return")
                     (codeof (car (childrenof tree))))
                  (body (printf ""))
                  (body (printf "()"))))
               (body
                (set thing (codeof (car (childrenof tree))))
                (if (equalBox (boxSymbol "get-struct") thing)
                  (body
                   (printf
                    "%s->%s"
                    (stringify (codeof (second (childrenof tree))))
                    (stringify (codeof (third (childrenof tree))))))
                  (body
                   (if (equalBox (boxSymbol "new") thing)
                     (body
                      (printf
                       "malloc(sizeof(%s))"
                       (stringify (codeof (third (childrenof tree))))))
                     (body
                      (printf
                       "%s("
                       (stringify
                        (ansiFuncMap (codeof (car (childrenof tree))))))
                      (ansiRecurList (cdr (childrenof tree)) indent)
                      (printf ")")))))))))))))))
  (void
   ansiIf
   (list node int indent)
   (declare)
   (body
    (newLine indent)
    (printf "if ( ")
    (ansiExpression (car (first (childrenof node))) 0)
    (printf ") {")
    (ansiBody (second (childrenof node)) (add1 indent))
    (newLine indent)
    (printf "} else {")
    (ansiBody (third (childrenof node)) (add1 indent))
    (newLine indent)
    (printf "}")))
  (void
   ansiSetStruct
   (list node int indent)
   (declare)
   (body
    (newLine indent)
    (printf
     "%s->%s = "
     (stringify (first (codeof node)))
     (stringify (second (codeof node))))
    (ansiExpression (childrenof node) indent)))
  (void
   ansiGetStruct
   (list node int indent)
   (declare)
   (body
    (newLine indent)
    (printf
     "%s->%s"
     (stringify (first (codeof node)))
     (stringify (second (codeof node))))))
  (void
   ansiSet
   (list node int indent)
   (declare)
   (body
    (newLine indent)
    (printf "%s = " (stringify (first (codeof node))))
    (ansiExpression (childrenof node) indent)))
  (void
   ansiStatement
   (list node int indent)
   (declare)
   (body
    (if (equalBox (boxString "setter") (subnameof node))
      (body (ansiSet node indent))
      (body
       (if (equalBox (boxString "structSetter") (subnameof node))
         (body (ansiSetStruct node indent))
         (body
          (if (equalBox (boxString "if") (subnameof node))
            (body (ansiIf node indent))
            (body
             (if (equalBox (boxString "returnvoid") (subnameof node))
               (body (newLine indent) (printf "return"))
               (body
                (newLine indent)
                (ansiExpression (childrenof node) indent)))))))))
    (printf ";\n")))
  (void
   printIndent
   (int ii)
   (declare)
   (body
    (if (> ii 0)
      (body (printf "  ") (printIndent (sub1 ii)))
      (body (return)))))
  (void
   newLine
   (int indent)
   (declare)
   (body (printf "\n") (printIndent indent)))
  (void
   ansiBody
   (list tree int indent)
   (declare)
   (body
    (if (isEmpty tree)
      (body (return))
      (body
       (printIndent indent)
       (printf
        "%s"
        "if (globalStepTrace) printf(\"StepTrace %s:%d\\n\", __FILE__, __LINE__);\n")
       (ansiStatement (car tree) indent)
       (ansiBody (cdr tree) indent)))))

  (void ansiDeclarations (list decls int indent) (declare (box decl nil))
   (body
    (if (isEmpty decls)
      (body (return))
      (body
       (set decl (car decls))
       (printf
        "%s %s = "
        (stringify (ansiTypeMap (first decl)))
        (stringify (second decl)))
       (display (ansiFuncMap (third decl)))
       (printf ";\n")
       (ansiDeclarations (cdr decls) indent)))))

    (list noStackTrace () (declare)
    (body
    (return 
     (cons (boxString "boxType")
     (cons (boxString "stringify")
     (cons (boxString "isEmpty")
     (cons (boxString "unBoxString")
     (cons (boxString "isList")
     (cons (boxString "unBoxBool")
     (cons (boxString "unBoxSymbol")
     (cons (boxString "equalBox")
     (cons (boxString "assoc")
     (cons (boxString "inList")
     (cons (boxString "unBoxInt")
     (cons (boxString "listLength")
     (cons (boxString "stroff")
     (cons (boxString "troff")
     (cons (boxString "tron")
     (cons (boxString "stron")
     (cons (boxString "car")
      (cons (boxString "cdr")
       (cons (boxString "cons")
        (cons (boxString "stackTracePush")
         (cons (boxString "stackTracePop")
          (cons (boxString "assertType")
           (cons (boxString "boxString")
           (cons (boxString "boxSymbol")
            (cons (boxString "boxInt") nil))))))))))))))))))))))))))))

(box toStr (box thing) (declare) 
    (body (return (boxString (stringify thing)))))

  (void ansiFunction (list node) (declare (box name nil))
   (body
    (set name (subnameof node))
    (printf "\n\n//Building function %s from line: %s" (stringify name) (stringify (getTag name (boxString "line"))))
    (newLine 0)
    (if (isNil node)
      (body (return))
      (body
       (newLine 0)
       (printf
        "%s %s("
        (stringify (ansiTypeMap (cdr (assoc "outtype" (cdr node)))))
        (stringify (subnameof node)))
       (ansiFunctionArgs (cdr (assoc "intype" (cdr node))))
       (printf ") {")
       (newLine 1)
       (ansiDeclarations (declarationsof node) 1)
       (if (inList (toStr name) (noStackTrace))
       (then (printf ""))
       (else 
           (printf "\nif (globalTrace)\n    printf(\"%s at %s:%s\\n\");\n" (stringify name) (stringify (getTag name (boxString "filename"))) (stringify (getTag name (boxString "line"))))))
       (if (inList (toStr name) (noStackTrace))
         (then (printf ""))
         (else
          (printf
           "\n  stackTracePush(\"%s\", \"%s\", %s, %d );\n"
           (stringify (getTag name (boxString "filename")))
           (stringify name)
           (stringify (getTag name (boxString "line")))
           0)))
       (ansiBody (childrenof node) 1)
       (if (inList (toStr name) (noStackTrace))
         (then (printf ""))
         (else
          (printf
           "\n  stackTracePop();\nif (globalTrace)\n    printf(\"Leaving %s\\n\");\n"
           (stringify name))))
       (printf "\n}\n")))))

  (void ansiForwardDeclaration (list node) (declare)
   (body
    (if (isNil node)
      (body (return))
      (body
       (printf
        "\n%s %s("
        (stringify (ansiTypeMap (cdr (assoc "outtype" (cdr node)))))
        (stringify (subnameof node)))
       (ansiFunctionArgs (cdr (assoc "intype" (cdr node))))
       (printf ");")))))
  (void
   ansiForwardDeclarations
   (list tree)
   (declare)
   (body
    (if (isEmpty tree)
      (body (return))
      (body
       (ansiForwardDeclaration (car tree))
       (ansiForwardDeclarations (cdr tree))))))
  (void
   ansiFunctions
   (list tree)
   (declare)
   (body
    (if (isEmpty tree)
      (body (return))
      (body (ansiFunction (car tree)) (ansiFunctions (cdr tree))))))
  (void
   ansiIncludes
   (list nodes)
   (declare)
   (body
    (printf
     "%s"
     "\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\nvoid panic(char* s){abort();}\nint sub(int a, int b) { return a - b; }\nfloat mult(int a, int b) { return a * b; }\nint greaterthan(int a, int b) { return a > b; }\nfloat subf(float a, float b) { return a - b; }\nfloat multf(float a, float b) { return a * b; }\nint greaterthanf(float a, float b) { return a > b; }\nint equal(int a, int b) { return a == b; }\nint equalString(char* a, char* b) { return !strcmp(a,b); }\nint andBool(int a, int b) { return a == b;}\nint string_length(char* s) { return strlen(s);}\nchar* sub_string(char* s, int start, int length) {\nchar* substr = calloc(length+1, 1);\nstrncpy(substr, s+start, length);\nreturn substr;\n}\n\n\n\nchar* stringConcatenate(char* a, char* b) {\nint len = strlen(a) + strlen(b) + 1;\nchar* target = calloc(len,1);\nstrncat(target, a, len);\nstrncat(target, b, len);\nreturn target;\n}\n\nchar* intToString(int a) {\nint len = 100;\nchar* target = calloc(len,1);\nsnprintf(target, 99, \"%d\", a);\nreturn target;\n}\n\ntypedef int*  array;\ntypedef int bool;\n#define true 1\n#define false 0\n\n\nvoid * gc_malloc( unsigned int size ) {\nreturn malloc( size);\n}\n\nint* makeArray(int length) {\n    int * array = gc_malloc(length*sizeof(int));\n    return array;\n}\n\nint at(int* arr, int index) {\n  return arr[index];\n}\n\nvoid setAt(int* array, int index, int value) {\n    array[index] = value;\n}\n\nchar * read_file(char * filename) {\nchar * buffer = 0;\nlong length;\nFILE * f = fopen (filename, \"rb\");\n\nif (f)\n{\n  fseek (f, 0, SEEK_END);\n  length = ftell (f);\n  fseek (f, 0, SEEK_SET);\n  buffer = malloc (length);\n  if (buffer == NULL) {\n  printf(\"Malloc failed!\\n\");\n  exit(1);\n}\n  if (buffer)\n  {\n    fread (buffer, 1, length, f);\n  }\n  fclose (f);\n}\nreturn buffer;\n}\n\n\nvoid write_file (char * filename, char * data) {\nFILE *f = fopen(filename, \"w\");\nif (f == NULL)\n{\n    printf(\"Error opening file!\");\n    exit(1);\n}\n\nfprintf(f, \"%s\", data);\n\nfclose(f);\n}\n\nchar* getStringArray(int index, char** strs) {\nreturn strs[index];\n}\n\nint start();  //Forwards declare the user's main routine\nchar** globalArgs;\nint globalArgsCount;\nbool globalTrace = false;\nbool globalStepTrace = false;\n\nint main( int argc, char *argv[] )  {\n  globalArgs = argv;\n  globalArgsCount = argc;\n\n  return start();\n\n}\n\n")))
  (box
   last
   (list alist)
   (declare)
   (body
    (if (isEmpty (cdr alist))
      (body (return (car alist)))
      (body (return (last (cdr alist)))))))
  (void
   ansiTypeDecl
   (list l)
   (declare)
   (body
    (if (> (listLength l) 2)
      (body
       (printIndent 1)
       (printf
        "%s %s %s;\n"
        (stringify (second l))
        (stringify (ansiTypeMap (last l)))
        (stringify (first l))))
      (body
       (printIndent 1)
       (printf
        "%s %s;\n"
        (stringify (ansiTypeMap (last l)))
        (stringify (car l)))))))
  (void
   ansiStructComponents
   (list node)
   (declare)
   (body
    (if (isEmpty node)
      (body (return))
      (body (ansiTypeDecl (car node)) (ansiStructComponents (cdr node))))))
  (void
   ansiStruct
   (list node)
   (declare)
   (body (ansiStructComponents (cdr (car node))) (return)))
  (box
   ansiTypeMap
   (box aSym)
   (declare (list symMap nil))
   (body
    (set
     symMap
     (alistCons
      (boxSymbol "stringArray")
      (boxSymbol "char**")
      (alistCons (boxSymbol "string") (boxSymbol "char*") nil)))
    (if (truthy (assoc (stringify aSym) symMap))
      (body (return (cdr (assoc (stringify aSym) symMap))))
      (body (return aSym)))))
  (box
   ansiFuncMap
   (box aSym)
   (declare (list symMap nil))
   (body
    (if (equalString "symbol" (boxType aSym))
      (body
       (set
        symMap
        (alistCons
         (boxSymbol "=")
         (boxSymbol "equal")
         (alistCons
          (boxSymbol "sub-string")
          (boxSymbol "sub_string")
          (alistCons
           (boxSymbol "read-file")
           (boxSymbol "read_file")
           (alistCons
            (boxSymbol "write-file")
            (boxSymbol "write_file")
            (alistCons
             (boxSymbol ">")
             (boxSymbol "greaterthan")
             (alistCons
              (boxSymbol "string-length")
              (boxSymbol "string_length")
              (alistCons (boxSymbol "nil") (boxSymbol "NULL") nil))))))))
       (if (truthy (assoc (stringify aSym) symMap))
         (body (return (cdr (assoc (stringify aSym) symMap))))
         (body (return aSym))))
      (body (return aSym)))))
  (void
   ansiType
   (list node)
   (declare)
   (body
    (if (equalBox (subnameof node) (boxString "struct"))
      (body
       (printf "\ntypedef struct %s {\n" (stringify (first (codeof node))))
       (ansiStruct (cdr (codeof node)))
       (printf "\n} %s;\n" (stringify (first (codeof node)))))
      (body (printf "typedef ") (ansiTypeDecl (codeof node))))
    (return)))
  (void
   ansiTypes
   (list nodes)
   (declare)
   (body
    (if (isEmpty nodes)
      (body (return))
      (body (ansiType (car nodes)) (ansiTypes (cdr nodes))))))
  (void
   ansiCompile
   (string filename)
   (declare (string programStr "") (list tree nil) (list program nil))
   (body
    (set programStr (read-file filename))
    (set tree (readSexpr programStr filename))
    (set
     program
     (alistCons
      (boxString "includes")
      (astIncludes (first tree))
      (alistCons
       (boxString "types")
       (astTypes (second tree))
       (alistCons (boxString "functions") (astFunctions (third tree)) nil))))
    (set program (mergeIncludes program))
    (ansiIncludes (cdr (assoc "includes" program)))
    (ansiTypes (childrenof (cdr (assoc "types" program))))
    (printf "Box* globalStackTrace = NULL;\n")
    (printf
     "\nbool isNil(list p) {\n    return p == NULL;\n}\n\n\n//Forward declarations\n")
    (ansiForwardDeclarations
     (cdr (assoc "children" (cdr (cdr (assoc "functions" program))))))
    (printf "\n\n//End forward declarations\n\n")
    (ansiFunctions
     (cdr (assoc "children" (cdr (cdr (assoc "functions" program))))))
    (printf "\n")))

  (list
   concatLists
   (list seq1 list seq2)
   (declare)
   (body
    (if (isNil seq1)
      (then (return seq2))
      (body (return (cons (car seq1) (concatLists (cdr seq1) seq2)))))))
  (list
   alistKeys
   (list alist)
   (declare)
   (body
    (if (isNil alist)
      (then (return nil))
      (else (return (cons (car (car alist)) (alistKeys (cdr alist))))))))
  (list
   mergeIncludes
   (list program)
   (declare)
   (body
    (return
     (merge_recur
      (childrenof (cdr (cdr (assoc "includes" program))))
      program))))
  (list
   merge_recur
   (list incs list program)
   (declare)
   (body
    (if (> (listLength incs) 0)
      (then
       (return (mergeInclude (car incs) (merge_recur (cdr incs) program))))
      (else (return program)))))

  (list
   mergeInclude
   (list inc list program)
   (declare
    (list newProgram nil)
    (list oldfunctionsnode nil)
    (list oldfunctions nil)
    (list newfunctions nil)
    (list newFunctionNode nil)
    (list functions nil)
    (list oldtypesnode nil)
    (list oldtypes nil)
    (list newtypes nil)
    (list newTypeNode nil)
    (list types nil))
   (body
    (if (isNil inc)
      (then (return program))
      (else
       (set functions (childrenof (cdr (assoc "functions" inc))))
       (set oldfunctionsnode (cdr (assoc "functions" program)))
       (set oldfunctions (childrenof oldfunctionsnode))
       (set newfunctions (concatLists functions oldfunctions))
       (set
        newFunctionNode
        (cons
         (boxSymbol "node")
         (alistCons
          (boxSymbol "children")
          newfunctions
          (cdr oldfunctionsnode))))
       (set types (childrenof (cdr (assoc "types" inc))))
       (set oldtypesnode (cdr (assoc "types" program)))
       (set oldtypes (childrenof oldtypesnode))
       (set newtypes (concatLists types oldtypes))
       (set
        newTypeNode
        (cons
         (boxSymbol "node")
         (alistCons (boxSymbol "children") newtypes (cdr oldtypesnode))))
       (set
        newProgram
        (alistCons
         (boxString "functions")
         newFunctionNode
         (alistCons
          (boxString "types")
          newTypeNode
          (alistCons
           (boxString "includes")
           (cons (boxSymbol "includes") nil)
           newProgram))))
       (return newProgram)))))
  ; Return command line args.  FIXME rename
    (list
   argList
   (int count int pos stringArray args)
   (declare)
   (body
    (if (> count pos)
      (body
       (return
        (cons
         (boxString (getStringArray pos args))
         (argList count (add1 pos) args))))
      (body (return nil)))))

  (list listReverse (list l) (declare)
   (body
    (if (isEmpty l)
      (body (return nil))
      (body (return (cons (car l) (listReverse (cdr l))))))))

  (bool inList (box item list l) (declare)
   (body
    (if (isNil l)
      (then (return false))
      (else
       ;(printf "Comparing %s and %s\n" (stringify item) (stringify (car l)))
       (if (equalBox (car l) item)
         (then (return true))
         (else (return (inList item (cdr l)))))))))

  (void stackTracePush (string file string fname int line int column) (declare)
   (body
    (set globalStackTrace
     (cons 
     (cons (boxString file) (cons (boxString fname) (cons (boxInt line) (cons (boxInt column) nil))))
      globalStackTrace))))

  (list stackTracePop () (declare (list top nil))
   (body
    (set top (car globalStackTrace))
    (set globalStackTrace (cdr globalStackTrace))
    (return top)))

  (void tron  () (declare) (body (set globalTrace true)))
  (void troff () (declare) (body (set globalTrace false)))
  (void stron  () (declare) (body (set globalStepTrace true)))
  (void stroff () (declare) (body (set globalStepTrace false)))
  ))
