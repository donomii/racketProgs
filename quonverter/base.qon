((includes)
 (types
  (Box
   (struct
    (lis struct Box*)
    (str string)
    (i int)
    (typ string)
    (voi bool)
    (boo bool)
    (lengt int)
    (car struct Box*)
    (cdr struct Box*)))
  (box Box*)
  (Pair Box)
  (pair Box*)
  (list Box*))
 (functions
  (int add (int a int b) (declare) (body (return (sub a (sub 0 b)))))
  (float addf (float a float b) (declare) (body (return (subf a (subf 0 b)))))
  (int sub1 (int a) (declare) (body (return (sub a 1))))
  (int add1 (int a) (declare) (body (return (add a 1))))
  (box
   clone
   (box b)
   (declare (box newb nil))
   (body
    (set newb (new newb Box))
    (set-struct newb typ (get-struct b typ))
    (set-struct newb lis (get-struct b lis))
    (set-struct newb str (get-struct b str))
    (set-struct newb i (get-struct b i))
    (set-struct newb lengt (get-struct b lengt))
    (return newb)))
  (box
   newVoid
   ()
   (declare (box newb nil))
   (body
    (set newb (new newb Box))
    (set-struct newb voi true)
    (set-struct newb typ "void")
    (return newb)))
  (list
   cons
   (box data list l)
   (declare (pair p nil))
   (body
    (set p (new pair Pair))
    (set-struct p cdr l)
    (set-struct p car data)
    (set-struct p typ "list")
    (return p)))
  (box
   car
   (list l)
   (declare)
   (body
    (assertType "list" l)
    (if (isNil l)
      (body
       (printf "Cannot call car on empty list!\n")
       (panic "Cannot call car on empty list!\n")
       (return nil))
      (body
       (if (isNil (get-struct l car))
         (body (return nil))
         (body (return (get-struct l car))))))))
  (list
   cdr
   (list l)
   (declare)
   (body
    (assertType "list" l)
    (if (isEmpty l)
      (body
       (printf "Attempt to cdr an empty list!!!!\n")
       (panic "Attempt to cdr an empty list!!!!\n")
       (return nil))
      (body (return (get-struct l cdr))))))
  (bool
   isList
   (box b)
   (declare)
   (body
    (if (isNil b)
      (body (return true))
      (body (return (equalString "list" (get-struct b typ)))))))
  (list emptyList () (declare) (body (return nil)))
  (bool
   isEmpty
   (box b)
   (declare)
   (body
    (if (isNil b)
      (body (return true))
      (body (if (isList b) (body (return false)) (body (return false)))))))
  (list
   alistCons
   (box key box value list alist)
   (declare)
   (body (return (cons (cons key value) alist))))
  (list
   assoc
   (string searchTerm list l)
   (declare (list elem nil))
   (body
    (assertType "list" l)
    (if (isEmpty l)
      (body (return (boxBool false)))
      (body
       (set elem (car l))
       (if (isEmpty elem)
         (body (return (assoc searchTerm (cdr l))))
         (body
          (if (equalString
               (stringify (boxString searchTerm))
               (stringify (car elem)))
            (body (return elem))
            (body (return (assoc searchTerm (cdr l)))))))))))
  (bool
   equalBox
   (box a box b)
   (declare)
   (body
    (if (isList b)
      (body (return false))
      (body
       (if (equalString "string" (boxType a))
         (body (return (equalString (unBoxString a) (stringify b))))
         (body
          (if (equalString "bool" (boxType a))
            (body (return (andBool (unBoxBool a) (unBoxBool b))))
            (body
             (if (equalString "symbol" (boxType a))
               (body
                (if (equalString "symbol" (boxType b))
                  (body (return (equalString (unBoxSymbol a) (unBoxSymbol b))))
                  (body (return false))))
               (body
                (if (equalString "int" (boxType a))
                  (body (return (equal (unBoxInt a) (unBoxInt b))))
                  (body (return false)))))))))))))
  (string boxType (box b) (declare) (body (return (get-struct b typ))))
  (box
   boxString
   (string s)
   (declare (box b nil))
   (body
    (set b (new box Box))
    (set-struct b str s)
    (set-struct b lengt (string-length s))
    (set-struct b typ "string")
    (return b)))
  (box
   boxSymbol
   (string s)
   (declare (box b nil))
   (body (set b (boxString s)) (set-struct b typ "symbol") (return b)))
  (box
   boxBool
   (bool boo)
   (declare (box b nil))
   (body
    (set b (new box Box))
    (set-struct b boo boo)
    (set-struct b typ "bool")
    (return b)))
  (box
   boxInt
   (int val)
   (declare (box b nil))
   (body
    (set b (new box Box))
    (set-struct b i val)
    (set-struct b typ "int")
    (return b)))
  (void
   assertType
   (string atype box abox)
   (declare)
   (body
    (if (isNil abox)
      (body (if (equalString atype "nil") (body (return)) (body (return))))
      (body
       (if (equalString atype (boxType abox))
         (body (return))
         (body
          (printf
           "Assertion failure: provided value is not a '%s'!  It was actually:"
           atype)
          (display abox)
          (panic "Invalid type!")))))))
  (string
   unBoxString
   (box b)
   (declare)
   (body (assertType "string" b) (return (get-struct b str))))
  (string unBoxSymbol (box b) (declare) (body (return (get-struct b str))))
  (bool unBoxBool (box b) (declare) (body (return (get-struct b boo))))
  (int unBoxInt (box b) (declare) (body (return (get-struct b i))))
  (string
   stringify
   (box b)
   (declare)
   (body
    (if (isNil b)
      (body (return "nil"))
      (body
       (if (equalString "string" (boxType b))
         (body (return (unBoxString b)))
         (body
          (if (equalString "bool" (boxType b))
            (body
             (if (unBoxBool b) (body (return "true")) (body (return "false"))))
            (body
             (if (equalString "symbol" (boxType b))
               (body (return (unBoxSymbol b)))
               (body (return (boxType b))))))))))))
  (void
   displayList
   (list l int indent)
   (declare (box val nil))
   (body
    (if (isEmpty l)
      (body (return))
      (body
       (if (isList l)
         (body
          (if (isEmpty l)
            (body (return))
            (body
             (set val (car l))
             (if (isList val)
               (body
                (newLine indent)
                (printf "%s" (openBrace))
                (displayList (car l) (add1 indent))
                (printf "%s" (closeBrace))
                (displayList (cdr l) (add1 indent)))
               (body
                (if (equalString "string" (get-struct val typ))
                  (body (printf "\"%s\" " (unBoxString val)))
                  (body (printf "%s " (stringify val))))
                (displayList (cdr l) indent))))))
         (body
          (if (equalString "string" (get-struct l typ))
            (body (printf "\"%s\" " (unBoxString l)))
            (body (printf "%s " (stringify l))))))))))
  (void
   display
   (list l)
   (declare)
   (body
    (if (isEmpty l)
      (body (printf "nil ") (return))
      (body
       (if (isList l)
         (body (printf "[") (displayList l 0) (printf "]"))
         (body (displayList l 0)))))))
  (list
   filterVoid
   (list l)
   (declare (box token nil))
   (body
    (if (isEmpty l)
      (body (return (emptyList)))
      (body
       (set token (car l))
       (if (equalString "void" (get-struct token typ))
         (body (return (filterVoid (cdr l))))
         (body (return (cons token (filterVoid (cdr l))))))))))
  (box
   finish_token
   (string prog int start int len)
   (declare)
   (body
    (if (> len 0)
      (body (return (boxSymbol (sub-string prog start len))))
      (body (return (newVoid))))))
  (string
   readString
   (string prog int start int len)
   (declare (string token ""))
   (body
    (set token (sub-string prog (sub1 (add start len)) 1))
    (if (equalString "\"" token)
      (body (return (sub-string prog start (sub1 len))))
      (body
       (if (equalString "\\" token)
         (body (return (readString prog start (add 2 len))))
         (body (return (readString prog start (add1 len)))))
       (return (readString prog start (add1 len)))))))
  (string
   readComment
   (string prog int start int len)
   (declare (string token ""))
   (body
    (set token (sub-string prog (sub1 (add start len)) 1))
    (if (equalString "\n" token)
      (body (return (sub-string prog start (sub1 len))))
      (body (return (readComment prog start (add1 len)))))))
  (bool
   isWhiteSpace
   (string s)
   (declare)
   (body
    (if (equalString " " s)
      (body (return true))
      (body
       (if (equalString "\n" s) (body (return true)) (body (return false)))))))
  (list
   scan
   (string prog int start int len)
   (declare (box token nil))
   (body
    (if (> (string-length prog) (sub start (sub 0 len)))
      (body
       (set token (boxSymbol (sub-string prog (sub1 (add start len)) 1)))
       (if (isOpenBrace token)
         (body
          (return
           (cons
            (finish_token prog start (sub1 len))
            (cons (boxSymbol (openBrace)) (scan prog (add1 start) 1)))))
         (body
          (if (isCloseBrace token)
            (body
             (return
              (cons
               (finish_token prog start (sub1 len))
               (cons (boxSymbol (closeBrace)) (scan prog (add start len) 1)))))
            (body
             (if (isWhiteSpace (stringify token))
               (body
                (return
                 (cons
                  (finish_token prog start (sub1 len))
                  (scan prog (add start len) 1))))
               (body
                (if (equalBox (boxSymbol ";") token)
                  (body
                   (return
                    (scan
                     prog
                     (add
                      start
                      (add1
                       (add1
                        (string-length (readComment prog (add1 start) len)))))
                     1)))
                  (body
                   (if (equalBox (boxSymbol "\"") token)
                     (body
                      (return
                       (cons
                        (boxString (readString prog (add1 start) len))
                        (scan
                         prog
                         (add
                          start
                          (add1
                           (add1
                            (string-length
                             (readString prog (add1 start) len)))))
                         1))))
                     (body (return (scan prog start (sub len -1))))))))))))))
      (body (return (emptyList))))
    (return (emptyList))))
  (bool
   isOpenBrace
   (box b)
   (declare)
   (body
    (if (equalBox (boxSymbol (openBrace)) b)
      (body (return true))
      (body
       (if (equalBox (boxSymbol "[") b)
         (body (return true))
         (body (return false)))))))
  (string openBrace () (declare) (body (return "(")))
  (bool
   isCloseBrace
   (box b)
   (declare)
   (body
    (if (equalBox (boxSymbol (closeBrace)) b)
      (body (return true))
      (body
       (if (equalBox (boxSymbol "]") b)
         (body (return true))
         (body (return false)))))))
  (string closeBrace () (declare) (body (return ")")))
  (list
   sexprTree
   (list l)
   (declare (box b nil))
   (body
    (if (isEmpty l)
      (body (return (emptyList)))
      (body
       (set b (car l))
       (if (isOpenBrace b)
         (body
          (return (cons (sexprTree (cdr l)) (sexprTree (skipList (cdr l))))))
         (body
          (if (isCloseBrace b)
            (body (return (emptyList)))
            (body (return (cons b (sexprTree (cdr l))))))))))
    (printf "AAAAAA code should never reach here!\n")
    (return (emptyList))))
  (list
   skipList
   (list l)
   (declare (box b nil))
   (body
    (if (isEmpty l)
      (body (return (emptyList)))
      (body
       (set b (car l))
       (if (isOpenBrace b)
         (body (return (skipList (skipList (cdr l)))))
         (body
          (if (isCloseBrace b)
            (body (return (cdr l)))
            (body (return (skipList (cdr l)))))))))
    (printf "AAAAAA code should never reach here!\n")
    (return (emptyList))))
  (list
   readSexpr
   (string aStr)
   (declare (list tokens nil) (list as nil))
   (body
    (set tokens (emptyList))
    (set tokens (filterVoid (scan aStr 0 1)))
    (set as (sexprTree tokens))
    (return (car as))))
  (void
   test0
   ()
   (declare)
   (body
    (if (equalString
         (stringify (boxString "hello"))
         (stringify (boxString "hello")))
      (body (printf "0.  pass string compare works\n"))
      (body (printf "0.  pass string compare fails\n")))
    (if (equalString
         (stringify (boxString "hello"))
         (stringify (boxSymbol "hello")))
      (body (printf "0.  pass string compare works\n"))
      (body (printf "0.  pass string compare fails\n")))))
 (box caar (list l) (declare) (body (return (car (car l)))))
  (box cadr (list l) (declare) (body (return (car (cdr l)))))
  (box caddr (list l) (declare) (body (return (car (cdr (cdr l))))))
  (box cadddr (list l) (declare) (body (return (car (cdr (cdr (cdr l)))))))
  (box
   caddddr
   (list l)
   (declare)
   (body (return (car (cdr (cdr (cdr (cdr l))))))))
  (box cddr (list l) (declare) (body (return (cdr (cdr l)))))
  (box first (list l) (declare) (body (return (car l))))
  (box second (list l) (declare) (body (return (cadr l))))
  (box third (list l) (declare) (body (return (caddr l))))
  (box fourth (list l) (declare) (body (return (cadddr l))))
  (box fifth (list l) (declare) (body (return (caddddr l))))
  (list
   makeNode
   (string name string subname list code list children)
   (declare)
   (body
    (return
     (cons
      (boxSymbol "node")
      (cons
       (cons (boxSymbol "name") (boxString name))
       (cons
        (cons (boxSymbol "subname") (boxString subname))
        (cons
         (cons (boxSymbol "code") code)
         (alistCons (boxSymbol "children") children (emptyList)))))))))
  (list
   astExpression
   (list tree)
   (declare)
   (body
    (if (isList tree)
      (body
       (return
        (makeNode "expression" "expression" nil (astSubExpression tree))))
      (body (return (astSubExpression tree))))))
  (list
   astSubExpression
   (list tree)
   (declare)
   (body
    (if (isEmpty tree)
      (body (return (emptyList)))
      (body
       (if (isList tree)
         (body
          (return
           (cons (astExpression (car tree)) (astSubExpression (cdr tree)))))
         (body (return (makeNode "expression" "leaf" tree nil))))))))
  (list
   astIf
   (list tree)
   (declare)
   (body
    (return
     (makeNode
      "statement"
      "if"
      tree
      (cons
       (cons (astExpression (first tree)) nil)
       (cons
        (astBody (cdr (second tree)))
        (cons (astBody (cdr (third tree))) nil)))))))
  (list
   astSetStruct
   (list tree)
   (declare)
   (body
    (return
     (makeNode "statement" "structSetter" tree (astExpression (third tree))))))
  (list
   astSet
   (list tree)
   (declare)
   (body
    (return
     (makeNode "statement" "setter" tree (astExpression (second tree))))))
  (list
   astGetStruct
   (list tree)
   (declare)
   (body (return (makeNode "expression" "structGetter" tree nil))))
  (list
   astReturnVoid
   ()
   (declare)
   (body (return (makeNode "statement" "returnvoid" nil nil))))
  (int
   length
   (list l)
   (declare)
   (body
    (if (isEmpty l)
      (body (return 0))
      (body (return (add1 (length (cdr l))))))))
  (list
   astStatement
   (list tree)
   (declare)
   (body
    (if (equalBox (boxString "if") (car tree))
      (body (return (astIf (cdr tree))))
      (body
       (if (equalBox (boxString "set") (car tree))
         (body (return (astSet (cdr tree))))
         (body
          (if (equalBox (boxString "get-struct") (car tree))
            (body
             (printf "Choosing get-struct statement\n")
             (return (astGetStruct (cdr tree))))
            (body
             (if (equalBox (boxString "set-struct") (car tree))
               (body (return (astSetStruct (cdr tree))))
               (body
                (if (equal (length tree) 1)
                  (body
                   (if (equalBox (car tree) (boxString "return"))
                     (body (return (astReturnVoid)))
                     (body
                      (return
                       (makeNode
                        "statement"
                        "statement"
                        tree
                        (makeNode
                         "expression"
                         "expression"
                         tree
                         (astExpression tree)))))))
                  (body
                   (return
                    (makeNode
                     "statement"
                     "statement"
                     tree
                     (makeNode
                      "expression"
                      "expression"
                      tree
                      (astExpression tree))))))))))))))))
  (list
   astBody
   (list tree)
   (declare)
   (body
    (if (isEmpty tree)
      (body (return (emptyList)))
      (body (return (cons (astStatement (car tree)) (astBody (cdr tree))))))))
  (list
   astFunction
   (list tree)
   (declare)
   (body
    (return
     (cons
      (cons (boxSymbol "name") (boxString "function"))
      (cons
       (cons (boxSymbol "subname") (second tree))
       (cons
        (cons (boxSymbol "declarations") (cdr (fourth tree)))
        (cons
         (cons (boxSymbol "intype") (third tree))
         (cons
          (cons (boxSymbol "outtype") (car tree))
          (cons
           (cons (boxSymbol "children") (astBody (cdr (fifth tree))))
           (emptyList))))))))))
  (list
   astFunctionList
   (list tree)
   (declare)
   (body
    (if (isEmpty tree)
      (body (return (emptyList)))
      (body
       (return
        (cons (astFunction (car tree)) (astFunctionList (cdr tree))))))))
  (list
   astFunctions
   (list tree)
   (declare)
   (body
    (return
     (makeNode "functions" "functions" tree (astFunctionList (cdr tree))))))
  (list
   loadLib
   (string path)
   (declare (string programStr "") (list tree nil) (list library nil))
   (body
    (set programStr (read-file path))
    (set tree (readSexpr programStr))
    (set
     library
     (alistCons
      (boxString "includes")
      (astIncludes (first tree))
      (alistCons
       (boxString "types")
       (astTypes (second tree))
       (alistCons (boxString "functions") (astFunctions (third tree)) nil))))
    (return library)))
  (list
   astInclude
   (list tree)
   (declare)
   (body (return (loadLib (stringify tree)))))
  (list
   astIncludeList
   (list tree)
   (declare)
   (body
    (if (isEmpty tree)
      (body (return (emptyList)))
      (body
       (return (cons (astInclude (car tree)) (astIncludeList (cdr tree))))))))
  (list
   astIncludes
   (list tree)
   (declare)
   (body
    (return
     (makeNode "includes" "includes" tree (astIncludeList (cdr tree))))))
  (list
   astStruct
   (list tree)
   (declare)
   (body (return (makeNode "type" "struct" tree nil))))
  (list
   astType
   (list tree)
   (declare)
   (body
    (if (isList (cadr tree))
      (body (return (astStruct tree)))
      (body (return (makeNode "type" "type" tree nil))))))
  (list
   astTypeList
   (list tree)
   (declare)
   (body
    (if (isEmpty tree)
      (body (return (emptyList)))
      (body (return (cons (astType (car tree)) (astTypeList (cdr tree))))))))
  (list
   astTypes
   (list tree)
   (declare)
   (body (return (makeNode "types" "types" tree (astTypeList (cdr tree))))))
  (void
   ansiFunctionArgs
   (list tree)
   (declare)
   (body
    (if (isEmpty tree)
      (body (return))
      (body
       (display (ansiTypeMap (first tree)))
       (display (second tree))
       (if (isNil (cddr tree)) (body (printf "")) (body (printf ",")))
       (ansiFunctionArgs (cddr tree))))))
  (list
   declarationsof
   (list ass)
   (declare)
   (body (return (cdr (assoc "declarations" (cdr ass))))))
  (list
   codeof
   (list ass)
   (declare)
   (body (return (cdr (assoc "code" (cdr ass))))))
  (list
   nodeof
   (list ass)
   (declare)
   (body
    (if (equalBox (boxBool false) (assoc "node" (cdr ass)))
      (body (return (boxBool false)))
      (body (return (cdr (assoc "node" (cdr ass))))))))
  (list
   subnameof
   (list ass)
   (declare)
   (body (return (cdr (assoc "subname" (cdr ass))))))
  (list
   nameof
   (list ass)
   (declare)
   (body (return (cdr (assoc "name" (cdr ass))))))
  (list
   childrenof
   (list ass)
   (declare)
   (body (return (cdr (assoc "children" (cdr ass))))))
  (bool
   isNode
   (list val)
   (declare)
   (body
    (if (isEmpty val)
      (body (return false))
      (body
       (if (isList val)
         (body
          (if (equalBox (boxSymbol "node") (car val))
            (body (return true))
            (body (return false))))
         (body (return false)))))))
  (void
   ansiLeaf
   (list thisNode int indent)
   (declare)
   (body (display (ansiFuncMap (codeof thisNode)))))
  (void
   ansiStructGetterExpression
   (list thisNode int indent)
   (declare)
   (body
    (if (equalBox (boxString "structGetter") (subnameof thisNode))
      (body (ansiGetStruct thisNode indent))
      (body (ansiLeaf thisNode indent)))))
  (void
   ansiExpression
   (list node int indent)
   (declare)
   (body
    (if (isLeaf node)
      (body (display (ansiFuncMap (codeof node))))
      (body (ansiSubExpression node indent)))))
  (void
   ansiRecurList
   (list expr int indent)
   (declare)
   (body
    (if (isEmpty expr)
      (body (return))
      (body
       (ansiExpression (car expr) indent)
       (if (isNil (cdr expr))
         (body (printf ""))
         (body (printf ", ") (ansiRecurList (cdr expr) indent)))))
    (return)))
  (bool
   isLeaf
   (list n)
   (declare)
   (body (return (equalBox (boxString "leaf") (subnameof n)))))
  (void
   ansiSubExpression
   (list tree int indent)
   (declare (box thing nil))
   (body
    (if (isEmpty tree)
      (body (return))
      (body
       (if (isNode (childrenof tree))
         (body (ansiSubExpression (childrenof tree) indent))
         (body
          (if (isLeaf tree)
            (body (display (ansiFuncMap (codeof tree))))
            (body
             (if (equal 1 (length (childrenof tree)))
               (body
                (display (codeof (car (childrenof tree))))
                (if (equalBox
                     (boxString "return")
                     (codeof (car (childrenof tree))))
                  (body (printf ""))
                  (body (printf "()"))))
               (body
                (set thing (codeof (car (childrenof tree))))
                (if (equalBox (boxSymbol "get-struct") thing)
                  (body
                   (printf
                    "%s->%s"
                    (stringify (codeof (second (childrenof tree))))
                    (stringify (codeof (third (childrenof tree))))))
                  (body
                   (if (equalBox (boxSymbol "new") thing)
                     (body
                      (printf
                       "malloc(sizeof(%s))"
                       (stringify (codeof (third (childrenof tree))))))
                     (body
                      (printf
                       "%s("
                       (stringify
                        (ansiFuncMap (codeof (car (childrenof tree))))))
                      (ansiRecurList (cdr (childrenof tree)) indent)
                      (printf ")")))))))))))))))
  (void
   ansiIf
   (list node int indent)
   (declare)
   (body
    (newLine indent)
    (printf "if ( ")
    (ansiExpression (car (first (childrenof node))) 0)
    (printf ") {")
    (ansiBody (second (childrenof node)) (add1 indent))
    (newLine indent)
    (printf "} else {")
    (ansiBody (third (childrenof node)) (add1 indent))
    (newLine indent)
    (printf "}")))
  (void
   ansiSetStruct
   (list node int indent)
   (declare)
   (body
    (newLine indent)
    (printf
     "%s->%s = "
     (stringify (first (codeof node)))
     (stringify (second (codeof node))))
    (ansiExpression (childrenof node) indent)))
  (void
   ansiGetStruct
   (list node int indent)
   (declare)
   (body
    (newLine indent)
    (printf
     "%s->%s"
     (stringify (first (codeof node)))
     (stringify (second (codeof node))))))
  (void
   ansiSet
   (list node int indent)
   (declare)
   (body
    (newLine indent)
    (printf "%s = " (stringify (first (codeof node))))
    (ansiExpression (childrenof node) indent)))
  (void
   ansiStatement
   (list node int indent)
   (declare)
   (body
    (if (equalBox (boxString "setter") (subnameof node))
      (body (ansiSet node indent))
      (body
       (if (equalBox (boxString "structSetter") (subnameof node))
         (body (ansiSetStruct node indent))
         (body
          (if (equalBox (boxString "if") (subnameof node))
            (body (ansiIf node indent))
            (body
             (if (equalBox (boxString "returnvoid") (subnameof node))
               (body (newLine indent) (printf "return"))
               (body
                (newLine indent)
                (ansiExpression (childrenof node) indent)))))))))
    (printf ";\n")))
  (void
   printIndent
   (int ii)
   (declare)
   (body
    (if (> ii 0)
      (body (printf "  ") (printIndent (sub1 ii)))
      (body (return)))))
  (void
   newLine
   (int indent)
   (declare)
   (body (printf "\n") (printIndent indent)))
  (void
   ansiBody
   (list tree int indent)
   (declare)
   (body
    (if (isEmpty tree)
      (body (return))
      (body
       (printIndent indent)
       (ansiStatement (car tree) indent)
       (ansiBody (cdr tree) indent)))))
  (void
   ansiDeclarations
   (list decls int indent)
   (declare (box decl nil))
   (body
    (if (isEmpty decls)
      (body (return))
      (body
       (set decl (car decls))
       (printf
        "%s %s = "
        (stringify (ansiTypeMap (first decl)))
        (stringify (second decl)))
       (display (ansiFuncMap (third decl)))
       (printf ";\n")
       (ansiDeclarations (cdr decls) indent)))))
  (void
   ansiFunction
   (list node)
   (declare)
   (body
    (if (isNil node)
      (body (return))
      (body
       (newLine 0)
       (printf
        "%s %s("
        (stringify (ansiTypeMap (cdr (assoc "outtype" (cdr node)))))
        (stringify (subnameof node)))
       (ansiFunctionArgs (cdr (assoc "intype" (cdr node))))
       (printf ") {")
       (newLine 1)
       (ansiDeclarations (declarationsof node) 1)
       (ansiBody (childrenof node) 1)
       (printf "\n}\n")))))
  (void
   ansiForwardDeclaration
   (list node)
   (declare)
   (body
    (if (isNil node)
      (body (return))
      (body
       (printf
        "\n%s %s("
        (stringify (ansiTypeMap (cdr (assoc "outtype" (cdr node)))))
        (stringify (subnameof node)))
       (ansiFunctionArgs (cdr (assoc "intype" (cdr node))))
       (printf ");")))))
  (void
   ansiForwardDeclarations
   (list tree)
   (declare)
   (body
    (if (isEmpty tree)
      (body (return))
      (body
       (ansiForwardDeclaration (car tree))
       (ansiForwardDeclarations (cdr tree))))))
  (void
   ansiFunctions
   (list tree)
   (declare)
   (body
    (if (isEmpty tree)
      (body (return))
      (body (ansiFunction (car tree)) (ansiFunctions (cdr tree))))))
  (void
   ansiIncludes
   (list nodes)
   (declare)
   (body
    (printf
     "\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\nvoid panic(char* s){abort();}\nint sub(int a, int b) { return a - b; }\nfloat mult(int a, int b) { return a * b; }\nint greaterthan(int a, int b) { return a > b; }\nfloat subf(float a, float b) { return a - b; }\nfloat multf(float a, float b) { return a * b; }\nint greaterthanf(float a, float b) { return a > b; }\nint equal(int a, int b) { return a == b; }\nint equalString(char* a, char* b) { return !strcmp(a,b); }\nint andBool(int a, int b) { return a == b;}\nint string_length(char* s) { return strlen(s);}\nchar* sub_string(char* s, int start, int length) {\nchar* substr = calloc(length+1, 1);\nstrncpy(substr, s+start, length);\nreturn substr;\n}\n\n\n\nchar* stringConcatenate(char* a, char* b) {\nint len = strlen(a) + strlen(b) + 1;\nchar* target = calloc(len,1);\nstrncat(target, a, len);\nstrncat(target, b, len);\nreturn target;\n}\n\ntypedef int*  array;\ntypedef int bool;\n#define true 1\n#define false 0\n\n\n\nvoid * gc_malloc( unsigned int size ) {\nreturn malloc( size);\n}\n\nint* makeArray(int length) {\n    int * array = gc_malloc(length*sizeof(int));\n    return array;\n}\n\nint at(int* arr, int index) {\n  return arr[index];\n}\n\nvoid setAt(int* array, int index, int value) {\n    array[index] = value;\n}\n\nchar * read_file(char * filename) {\nchar * buffer = 0;\nlong length;\nFILE * f = fopen (filename, \"rb\");\n\nif (f)\n{\n  fseek (f, 0, SEEK_END);\n  length = ftell (f);\n  fseek (f, 0, SEEK_SET);\n  buffer = malloc (length);\n  if (buffer)\n  {\n    fread (buffer, 1, length, f);\n  }\n  fclose (f);\n}\nreturn buffer;\n}\n\n\nvoid write_file (char * filename, char * data) {\nFILE *f = fopen(filename, \"w\");\nif (f == NULL)\n{\n    printf(\"Error opening file!\");\n    exit(1);\n}\n\nfprintf(f,  data);\n\nfclose(f);\n}\n\nchar* getStringArray(int index, char** strs) {\nreturn strs[index];\n}\n\nint start();  //Forwards declare the user's main routine\nchar** globalArgs;\nint globalArgsCount;\n\nint main( int argc, char *argv[] )  {\n  globalArgs = argv;\n  globalArgsCount = argc;\n\n  return start();\n\n}\n\n")))
  (box
   last
   (list alist)
   (declare)
   (body
    (if (isEmpty (cdr alist))
      (body (return (car alist)))
      (body (return (last (cdr alist)))))))
  (void
   ansiTypeDecl
   (list l)
   (declare)
   (body
    (if (> (length l) 2)
      (body
       (printIndent 1)
       (printf
        "%s %s %s;\n"
        (stringify (second l))
        (stringify (ansiTypeMap (last l)))
        (stringify (first l))))
      (body
       (printIndent 1)
       (printf
        "%s %s;\n"
        (stringify (ansiTypeMap (last l)))
        (stringify (car l)))))))
  (void
   ansiStructComponents
   (list node)
   (declare)
   (body
    (if (isEmpty node)
      (body (return))
      (body (ansiTypeDecl (car node)) (ansiStructComponents (cdr node))))))
  (void
   ansiStruct
   (list node)
   (declare)
   (body (ansiStructComponents (cdr (car node))) (return)))
  (bool
   truthy
   (box aVal)
   (declare)
   (body
    (if (equalBox (boxBool false) aVal)
      (body (return false))
      (body (return true)))))
  (box
   ansiTypeMap
   (box aSym)
   (declare (list symMap nil))
   (body
    (set
     symMap
     (alistCons
      (boxSymbol "stringArray")
      (boxSymbol "char**")
      (alistCons (boxSymbol "string") (boxSymbol "char*") nil)))
    (if (truthy (assoc (stringify aSym) symMap))
      (body (return (cdr (assoc (stringify aSym) symMap))))
      (body (return aSym)))))
  (box
   ansiFuncMap
   (box aSym)
   (declare (list symMap nil))
   (body
    (if (equalString "symbol" (boxType aSym))
      (body
       (set
        symMap
        (alistCons
         (boxSymbol "=")
         (boxSymbol "equal")
         (alistCons
          (boxSymbol "sub-string")
          (boxSymbol "sub_string")
          (alistCons
           (boxSymbol "read-file")
           (boxSymbol "read_file")
           (alistCons
            (boxSymbol "write-file")
            (boxSymbol "write_file")
            (alistCons
             (boxSymbol ">")
             (boxSymbol "greaterthan")
             (alistCons
              (boxSymbol "string-length")
              (boxSymbol "string_length")
              (alistCons (boxSymbol "nil") (boxSymbol "NULL") nil))))))))
       (if (truthy (assoc (stringify aSym) symMap))
         (body (return (cdr (assoc (stringify aSym) symMap))))
         (body (return aSym))))
      (body (return aSym)))))
  (void
   ansiType
   (list node)
   (declare)
   (body
    (if (equalBox (subnameof node) (boxString "struct"))
      (body
       (printf "\ntypedef struct %s {\n" (stringify (first (codeof node))))
       (ansiStruct (cdr (codeof node)))
       (printf "\n} %s;\n" (stringify (first (codeof node)))))
      (body (printf "typedef ") (ansiTypeDecl (codeof node))))
    (return)))
  (void
   ansiTypes
   (list nodes)
   (declare)
   (body
    (if (isEmpty nodes)
      (body (return))
      (body (ansiType (car nodes)) (ansiTypes (cdr nodes))))))
  (list
   concatLists
   (list seq1 list seq2)
   (declare)
   (body
    (if (isNil seq1)
      (then (return seq2))
      (body (return (cons (car seq1) (concatLists (cdr seq1) seq2)))))))
  (list
   alistKeys
   (list alist)
   (declare)
   (body
    (if (isNil alist)
      (then (return nil))
      (else (return (cons (car (car alist)) (alistKeys (cdr alist))))))))
  (list
   mergeIncludes
   (list program)
   (declare
    (list newProgram nil)
    (list oldfunctionsnode nil)
    (list oldfunctions nil)
    (list newfunctions nil)
    (list newFunctionNode nil)
    (list functions nil))
   (body
    (if (> (length (childrenof (cdr (cdr (assoc "includes" program))))) 0)
      (then
       (set
        functions
        (childrenof
         (cdr
          (assoc
           "functions"
           (car (childrenof (cdr (cdr (assoc "includes" program)))))))))
       (set oldfunctionsnode (cdr (assoc "functions" program)))
       (set oldfunctions (childrenof oldfunctionsnode))
       (set newfunctions (concatLists functions oldfunctions))
       (set
        newFunctionNode
        (cons
         (boxSymbol "node")
         (alistCons
          (boxSymbol "children")
          newfunctions
          (cdr oldfunctionsnode))))
       (set
        newProgram
        (alistCons
         (boxString "functions")
         newFunctionNode
         (alistCons
          (boxString "types")
          (cdr (assoc "types" program))
          (alistCons
           (boxString "includes")
           (cons (boxSymbol "includes") nil)
           newProgram))))
       (return newProgram))
      (else (return program)))))
  (void
   compile
   (string filename)
   (declare (string programStr "") (list tree nil) (list program nil))
   (body
    (set programStr (read-file filename))
    (set tree (readSexpr programStr))
    (set
     program
     (alistCons
      (boxString "includes")
      (astIncludes (first tree))
      (alistCons
       (boxString "types")
       (astTypes (second tree))
       (alistCons (boxString "functions") (astFunctions (third tree)) nil))))
    (set program (mergeIncludes program))
    (ansiIncludes (cdr (assoc "includes" program)))
    (ansiTypes (childrenof (cdr (assoc "types" program))))
    (printf
     "\nbool isNil(list p) {\n    return p == NULL;\n}\n\n\n//Forward declarations\n")
    (ansiForwardDeclarations
     (cdr (assoc "children" (cdr (cdr (assoc "functions" program))))))
    (printf "\n\n//End forward declarations\n\n")
    (ansiFunctions
     (cdr (assoc "children" (cdr (cdr (assoc "functions" program))))))
    (printf "\n")))
  (list
   argList
   (int count int pos stringArray args)
   (declare)
   (body
    (if (> count pos)
      (body
       (return
        (cons
         (boxString (getStringArray pos args))
         (argList count (add1 pos) args))))
      (body (return nil)))))
  (list
   reverse
   (list l)
   (declare)
   (body
    (if (isEmpty l)
      (body (return nil))
      (body (return (cons (car l) (reverse (cdr l))))))))
  ))
