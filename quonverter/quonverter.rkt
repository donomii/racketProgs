#lang racket
[require srfi/1]
; Support functions
[define [id x] x]
[define [walk tree func]
  [if [list? tree]
      [map [lambda [branch] [walk branch func]] [func tree]]
      tree
      ]]



(define (swap-every-2 lst)
  (if (or (null? lst) 
          (null? (cdr lst)))
      lst
      (list* (cadr lst) 
             (car lst) 
             (swap-every-2 (cddr lst)))))

(define (ndelete lst n)
  (let recur ((i 1)
              (rest lst))
    (cond ((null? rest) '())
          ((= i n) (recur 1 (cdr rest)))
          (else (cons (car rest) (recur (+ i 1) (cdr rest)))))))

(define (nth-places n lst [i 0])
  (cond
    [(null? lst) null]
    [(= i 0) (cons (car lst)
                   (nth-places n (cdr lst) (+ i 1)))]
    [(= i n) (nth-places n (cdr lst) 0)]
    [else (nth-places n (cdr lst) (+ i 1))]))

[define [make-pairs lst]
  [if [empty? lst]
      lst
      [cons [take lst 2] [make-pairs [drop lst 2]]]]
  ]



; C output functions

;output include statements
[define [clang_includes tree]
  [list
   [map [lambda [x]  [format "#include <~s>~n
int sub(int a, int b) { return a - b; }
int greaterthan(int a, int b) { return a > b; }
int equal(int a, int b) { return a == b; }"
                             x] ] [cons 'stdio.h [cdr [codeof tree]]]]
   "\n"]]

[define [clang_arguments tree]
  [list "("
        [string-join [map [lambda [x]  [format "~a ~a" [clang_typemap [car x]] [cadr x]]] [make-pairs [codeof tree]]] ", "]
        ")"]]

[define [clang_detect_variable types atom]
  ;[display [format "Types: ~s    Atom: ~s~n" types atom]]
  [if [assoc atom types]
      [format "$~a"  atom ]
      atom
      ]
  ]

[define [clang_subexpression node]
  [displayln[format  "subexpr: ~s" node]][newline]
  [if [is-leaf? node]
      [format "~s" [codeof node]]
      [clang_expression node]]]

;output an expression.  Soon, recursive!
[define [clang_expression tree]
  ;[displayln[format  "expression: ~s" tree]][newline]
  [when [not [is-node? tree]] [error "Not a node!"]]
  [if [is-leaf? tree]
      [begin [displayln "atom"]
             [format "~s" [clang_funcmap [codeof tree]]]]
     [if [equal? 1 [length tree]]
          ;a function with no args
          [format "~a()" [codeof [first  tree]]]
      [begin [displayln [format  "definite function ~s" [childrenof tree]]]
             [string-join [list [format "~a(" [clang_funcmap [codeof [car  [childrenof tree]]]]]
                                [string-join [map [lambda [x] [format "~a" [clang_subexpression x]  ]] [cdr  [childrenof tree]]] ", "]
                                ")"] ""]]]]
  ]

;output a statement.  This is where all the builtins go, like "if, set, for"
[define [clang_statement tree]
  [displayln [format  "clang statement: ~s" [pretty-print tree]]][newline]
  [list
   [case [car [codeof  tree]]
     ['if [format "    if ( ~a ) {\n      ~a    } else {\n      ~a    }"
                  [clang_expression   [first [childrenof tree]]]
                  [string-join [flatten [clang_body  [second [childrenof tree]]]]]
                  [string-join [flatten[clang_body [third [childrenof tree]]]]]
                  ]]
     ['set  [format "    ~a=~a;" [codeof [first [childrenof tree]]] [clang_expression  [second [childrenof tree]]]]]
     [else [list [format "    ~a(" [car [codeof tree]]]
                 [string-join [map [lambda [x] [format "~s" x]] [cdr [codeof tree]]] ", "]
                 ");"]]]
   "\n"]]

;All variables in a function must be declared at the start in one block.  Declarations cannot reference other declarations
[define [clang_declaration tree]
  [match-let [[[list type name value] [codeof tree]]]
    [format "    ~a ~a = ~s;\n"  [clang_typemap type] name  value]]]


;Print the body of the function, all statements
[define [clang_body tree]
  [map clang_statement  tree]]


;Output the body of function
[define [clang_function tree]
  [match-let [[[list type name args decs  bod] [childrenof tree]]]
    [list
     [format "~a ~a" [clang_typemap [codeof type]] [codeof name]]
     [clang_arguments args]
     [format " {~n" ]
     [clang_declarations decs]
     [clang_body bod]
     "}\n\n"]]]


;Turns quonverter types into C types
[define [clang_typemap type]
  [case type
    ['string "char*"]
    [else type]]]

;Renames quonverter funcs into C funcs.
[define [clang_funcmap name]
  [case name
    ['= 'equal]
    ['true '1]
    ['- 'sub]
    ['> 'greaterthan]
    [else name]]]

;Print all the declarations
[define [clang_declarations tree]
  [map clang_declaration  [childrenof tree]]]

;Print all the functions
[define [clang_functions tree]
  [map clang_function [childrenof tree]]]

;This can go away, move it to the "program" node
[define [clang_dispatch tree]
  [case [nameof tree]
    [(functions)   [clang_functions tree]]
    [(includes)  [clang_includes tree]]]]

;The top level node
[define [clang_program tree]
  [string-join [flatten [map clang_dispatch  [childrenof tree]]] ""]]

;Autogenerated test file
[define clang_test_filename "test.c"]

;Compile and run the test program
[define clang_test_commands '["gcc test.c" "./a.out > results.c"]]



; Golang output functions

[define [go_includes tree]
  [list
   "package main\n\nimport \"fmt\"\n\n
   func sub(a, b int) int{
return a-b
}

func greaterthan(a, b int) bool {
return a>b
}
func equal(a,b int) bool {
return a==b
}
"
   [map [lambda [x]  [format "import \"~a\"~n" x] ] [cdr [codeof tree]]]
   ]]

[define [go_arguments tree]
  [list "("
        [string-join [map [lambda [x]  [format "~a ~a" [cadr x] [car x]]] [make-pairs [codeof tree]]] ", "]
        ")"
        ]]


[define [is-node? n]
  [assoc'types n]]

[define [is-leaf? n]
  [equal? [nameof n] 'leaf]]

[define [is-expression? n]
  [equal? [nameof n] 'expression]]



[define [go_subexpression node]
  [displayln[format  "subexpr: ~s" node]][newline]
  [if [is-leaf? node]
      [format "~s" [codeof node]]
      [go_expression node]]]

;output an expression.  Soon, recursive!
[define [go_expression tree]
  ;[displayln[format  "expression: ~s" tree]][newline]
  [when [not [is-node? tree]] [error "Not a node!"]]
  [if [is-leaf? tree]
      [begin [displayln "atom"]
             [format "~s" [go_funcmap [codeof tree]]]]
     [if [equal? 1 [length tree]]
          ;a function with no args
          [format "~a()" [codeof [first  tree]]]
      [begin [displayln [format  "definite function ~s" [childrenof tree]]]
             [string-join [list [format "~a(" [go_funcmap [codeof [car  [childrenof tree]]]]]
                                [string-join [map [lambda [x] [format "~a" [go_subexpression x]  ]] [cdr  [childrenof tree]]] ", "]
                                ")"] ""]]]]
  ]



[define [go_statement tree]
  [write "go statement:"][writeln tree][newline]
  [write "go childrenof statement:"][writeln [childrenof tree]][newline]
  [list
   [case [car [codeof  tree]]
     ['if [format "    if ~a {\n      ~a    } else {\n      ~a    }"
                  [go_expression   [car [childrenof tree]]]
                  [string-join [flatten [go_body  [second [childrenof tree]]]]]
                  [string-join [flatten[go_body [third [childrenof tree]]]]]
                  ]]
     ['set  [format "    ~a=~a"  [codeof [first [childrenof tree]]] [go_subexpression [second  [childrenof tree]]]]]
     [else [list [format "    ~a(" [go_funcmap [car [codeof tree]]]]
                 [string-join [map [lambda [x] [format "~s" x]] [cdr [codeof tree]]] ", "]
                 ")"]]]
   "\n"]]

[define [go_declaration tree]
  [match-let [[[list type name value] [codeof tree]]]
    [format "    var ~a ~a = ~s\n"  name type value]]]



[define [go_main tree]
  [match-let [[[list type name args decs  bod] [childrenof tree]]]
    [list
     "func main() {\n"
     [go_declarations decs]
     [go_body bod]
     "}\n"
     ]]]

[define [go_body tree]
  [list
   [map go_statement  tree]
   ]]



[define [go_function tree]
  [match-let [[[list type name args decs  bod] [childrenof tree]]]
    [if [equal? [codeof name] 'main]
        [go_main tree]
        [list
         [format "func ~a " [codeof name]]
         [go_arguments args]
         [format " ~a {~n" [go_typemap [codeof type]]]
         [go_declarations decs]
         [go_body bod]
         "}\n\n"]]]]


[define [go_typemap type]
  [case type
    ['void ""]
    [else type]]]

[define [go_funcmap name]
  [case name
    ['= 'equal]
    ['printf 'fmt.Printf]
    ['- 'sub]
    ['> 'greaterthan]
    ['true 'true]
    [else name]]]


[define [go_declarations tree]
  [map go_declaration  [childrenof tree]]]


[define [go_functions tree]
  [map go_function [childrenof tree]]]

[define [go_dispatch tree]
  [case [nameof tree]
    [(functions)   [go_functions tree]]
    [(includes)  [go_includes tree]]]]

[define [go_program tree]
  [string-join [flatten [map go_dispatch  [childrenof tree]]] ""]]

[define go_test_filename "test.go"]

[define go_test_commands '["/Users/jeremyprice/go-git/bin/go run test.go > results.go"]]



;
;; BASH output functions

[define [bash_includes tree]
  [list "#!/bin/bash\n\n
function sub {
 let \"returnValue = $1 - $2 \"
}
function greaterthan {
 [ $1 -gt $2  ]
 let returnValue=$?
}
function soTrue {
let returnValue=true
}
"
        [map [lambda [x]  [format "~n"] ] [cdr tree]]
        ]]

[define [bash_arguments tree]
  [list 
   [map [lambda [x i] [format "    local ~a=$~a~n" x i]] [nth-places 1 [codeof tree] 1] [iota [length tree] 1 1]]]]


[define [bash_expression types tree]
  ;[displayln [format "bash_expression: ~a" tree]]
  [if [list? tree]
      [string-join [list [format "~a " [bash_funcmap [car  tree]]]
                         [string-join [map [lambda [x] [format "~s" [bash_detect_variable types x]]] [cdr  tree]] " "]
                         ] ""]
      [bash_funcmap[bash_detect_variable types tree]]]
  ]

[define [bash_detect_variable types atom]
  ;[display [format "Types: ~s    Atom: ~s~n" types atom]]
  [if [assoc atom types]
      [format "$~a"  atom ]
      atom
      ]
  ]

[define [bash_statement tree]
  ;[displayln tree]
  [list
   [case [car [codeof tree]]
     ['if [format "    ~a~n    if (( $returnValue == 0 ));\n    then\n      ~a    else\n      ~a    fi"
                  [bash_expression [typesof tree] [codeof [first [childrenof tree]]]]
                  [string-join [flatten [bash_body [second [childrenof tree]]]] ""]
                  [string-join [flatten [bash_body [third [childrenof tree]]]]""]
                  ]]
     ['set [format "    ~a\n    local ~a=$returnValue"  [bash_expression [typesof tree] [second [childrenof tree]]]  [first [childrenof tree]]  ]]
     ['return [format "returnValue=~s" [bash_expression [typesof tree] [second [codeof tree]]]]]
     [else [list
            [format "    ~a " [bash_funcmap [car [codeof tree]]]]
            [map [lambda [x]  [format "~s " [bash_detect_variable [typesof tree] x]]] [cdr [codeof tree]]]
            ]]]
   "\n"]]

[define [bash_declaration tree]
  [match-let [[[list type name value] [codeof tree]]]
    [format "    local ~a=~a~n"   name value]]]




[define [bash_main tree]
  [match-let [[[list type name args decs  bod] [childrenof tree]]]
    [list
     "function main {\n" 
     [bash_declarations decs]
     [bash_body bod]
     "}\n"
     "main"
     ]]]

[define [bash_body tree]
  [map [lambda [x] [bash_statement x]] tree]
  ]




[define [bash_function tree]
  [match-let [[[list type name args decs  bod] [childrenof tree]]]
    [if [equal? [codeof name] 'main]
        [bash_main tree]
        [list
         [format "function ~a {\n" [codeof name]]
         [bash_arguments args]
         [format " ~a" [bash_typemap [codeof type]]]
         [bash_declarations decs]
         [bash_body bod]
         "}\n\n"
         ]]]
  ]


[define [bash_typemap type]
  ""
  ]



[define [bash_funcmap name]
  ;[displayln [format "funcmap: ~a" name]]
  [case name
    ['printf 'printf]
    ['- 'sub]
    ['> 'greaterthan]
    ['true 'soTrue]
    [else name]]]


[define [bash_declarations tree]
  [map bash_declaration  [childrenof tree]]]


[define [bash_functions tree]
  [map bash_function [childrenof tree]]]

[define [bash_dispatch tree]
  [case [nameof tree]
    [(functions)   [bash_functions tree]]
    [(includes)  [bash_includes tree]]]]

[define [bash_program tree]
  [string-join [flatten [map bash_dispatch  [childrenof tree]]] ""]]

[define bash_test_filename "test.bash"]

[define bash_test_commands '["bash test.bash > results.bash"]]




;
;; BAT output functions
;
;[define [includes tree]
;  [list [format "ECHO ON~nSETLOCAL ENABLEEXTENSIONS~nCALL main~nEXIT /B 0~n"]
;  [map [lambda [x] [format "~n"] ] [cdr tree]]]]
;
;[define [arguments tree]
;  [list "\n"
;  [map [lambda [x i] [format "    SET ~a=%~a~n" x i]] [nth-places 2 tree -1] [iota [length tree] 1 1]]]
;
;  ]
;
;[define [statement tree]
;  [list
;  [case [car tree]
;    ['set  [format "    SET ~a=~a~n" [cadr tree] [caddr tree]]]
;  [else [begin [list [format "    ~a " [car tree]]
;   [map [lambda [x] [format "~s " x]] [cdr tree]]]
;   ]]]
;        "\n"]
;  ]
;
;[define [declaration tree]
;  [match-let [[[list type name value] tree]]
;    [format "    SET ~a=~a~n"  name value]]]
;
;
;[define [main tree]
;[match-let [[[list type name args decs  bod] tree]]
;  [list 
;  [format "~n~n:~a~n" name]
;    [declarations decs]
;    [map [lambda [x] [statement x]] [cdr bod]]
;    "EXIT /B 0"]
;  ]]
;
;[define [body tree]
;  [list
;  [map [lambda [x] [statement x]] [cdr tree]]
;  "EXIT /B 0"
;  "\n"]
;  ]
;
;[define [function tree]
;  [match-let [[[list type name args decs  bod] tree]]
;    [if [equal? name 'main]
;        [main tree]
;        [list
;    [format "~n~n:~a " name]
;    [arguments args]
;    [format " ~a" [typemap type]]
;    [declarations decs]
;    [body bod]
;     "EXIT /B 0"
;  ]]]
;  ]
;
;
;[define [typemap type]
;  ]


; Type functions


[define [make-node type code name children]
  [list
   [cons 'types type]
   [cons 'code code]
   [cons 'name name]
   [cons 'children children]
   ]]


[define [default_node codetree name]
  [list
   [cons 'types '[]]
   [cons 'code codetree]
   [cons 'name name]
   [cons 'children '[]]]]

[define [type_includes tree]
  [default_node tree 'includes
    ]]



[define [type_arguments tree]
  [make-node   [map [lambda [x]  [cons  [cadr x] [car x]]] [make-pairs tree]]
               tree
               'function_arguments
               '[]]]

[define [type_expression scope tree]
  [displayln [format "type_expr: ~s" tree]]
  [if [list? tree]
       [make-node scope tree 'expression [map [lambda [x] [type_expression scope x]] tree]]
       [make-node scope tree 'leaf '[]  ]
      ]]

[define [type_statement scope tree]
  [display [format "type statement: ~s~n" tree]]
  [case [car tree]
    ['if [letrec [[condition  [type_condition scope [second tree]]]
                  [truBranch [type_body scope  [third tree]]]
                  [falseBranch [type_body scope [fourth tree] ]]]
           [make-node scope '[if] 'statement [list condition truBranch falseBranch]]]]
    ['set [make-node scope '[set] 'statement [list [default_node [second tree] [second tree]]   [type_expression scope [third tree]] ] ]]
    [else
     [make-node scope tree "statement" [list [type_expression scope tree]]]]]]

[define [type_declaration tree]
  [match-let [[[list type name value] tree]]
    [list
     [cons 'types [list [cons name type]]]
     [cons 'code tree]
     ]
    ]]

[define [typesof x]
  [if [equal? [length x] 1]
      '[]
      [cdr [assoc 'types  x]]]]


[define [codeof x]
  [if [equal? [length x] 1]
      '[]
      [cdr [assoc 'code  x]]
      ]
  ]

[define [nameof x]
  [if [equal? [length x] 1]
      '[]
      [cdr [assoc 'name  x]]]]

[define [childrenof x]
  [if [equal? [length x] 1]
      '[]
      [cdr [assoc 'children  x]]
      ]
  ]
 

[define [type_condition scope tree]
  [if [list? tree]
      [type_expression scope tree]
      [make-node scope tree 'leaf '[]]]]

[define [type_body scope tree]
  [map [lambda [x] [type_statement scope x]] [cdr tree]]]



[define [type_function tree]
  [match-let [[[list type name args decs  bod] tree]]
      
    [letrec [[typeArgs [typesof [type_arguments args]]]
             [allTypes  [make-node [append [typesof  [type_declarations decs]] typeArgs ]
                                   [cons 'code '[]]
                                   "function_types"
                                   '[]]]]
      [make-node '[] '[] 'function
                 [list
                  [make-node type type 'function_type '[]]
                  [default_node name 'function_name]
                  [type_arguments args ]
                  [type_declarations decs ]
                  [type_body [typesof allTypes] bod ]
                  ]
                 ]]]]



[define [type_declarations tree]
  [if [empty? [cdr tree]]
      [default_node '[] 'variable_declarations]
        
      [make-node [map [lambda [x] [car [typesof [type_declaration x]]]] [cdr tree]]
               
                 tree
                 'variable_declarations
                 [map type_declaration [cdr tree]]]]]


[define [type_functions tree]
  [map type_function [cdr tree]]]

[define [type_annotate tree]
  [map type_dispatch tree]]

[define [type_dispatch tree]
  [case [car tree]
    [(functions)   [make-node '[] "" 'functions [type_functions tree]]]
    [(includes)  [type_includes tree]]
    ]]


[define [type_program tree]
  [make-node '[] "" 'program [map type_dispatch tree]]]









;Common funcs

[define prog
  '[
    ;[includes stdio.h stdlib.h]
    [includes]
    [functions


     [void test1 [] [declare]
           [body [printf "1.  pass Function call and print work\n"]]]

     [void test2_do [string message] [declare]
           [body [printf "2.  pass Function call with arg works: %s\n" message]]]
           
     [void test2 [] [declare]
           [body [test2_do "This is the argument"]]]

     [void test3_do [int b string c]
           [declare]
           [body 
            [printf "3.1 pass Two arg call, first arg: %d\n" b]
            [printf "3.2 pass Two arg call, second arg: %s\n" c]
            ]]
     
     [void test3 [] [declare]
           [body [test3_do 42 "Fourty-two"]]]

     [string test4_do [] [declare]
             [body [return "pass Return works"]]]

     [string returnThis [string returnMessage] [declare]
             [body [return returnMessage]]]

     [void test4 [] [declare [string message "fail"]]
           [body
            [set message [test4_do]]
            [printf "4.  %s\n" message]]]

     [void test5 [] [declare [string message "fail"]]
           [body
            [set message [returnThis "pass return passthrough string"]]
            [printf "5.  %s\n" message]
            ]]

     [void test6 [] [declare]
           [body
            [if true
                [body [printf "6.  pass If statement works\n"]]
                [body [printf "6.  fail If statement works\n"]]]
            ]]

     [int test7_do [int count] [declare]
          [body
           [set count [sub count 1]]
           ;[printf "Count: %d\n" count]
           [if [> count 0]
               [body [set count [test7_do count]]]
               [body [return count]]]
           [return count]
           ]]
     
     [void test7 [] [declare ]
           [body
            
            [printf "Counting down from 10\n"]
            [if [= 0 [test7_do 10]]
                [body [printf "7.  pass count works\n"]]
                [body [printf "7.  fail count fails\n"]]]
            ]]

     [void beer [] [declare] [body
                              [printf "%d bottle of beer on the wall, %d bottle of beer.  Take one down, pass it round, no bottles of beer on the wall\n" 1 1]]]
     [int beers [int count] [declare [int newcount 0]]
          [body
           [set newcount [sub count 1]]
           [printf "%d bottles of beer on the wall, %d bottles of beer.  Take one down, pass it round, %d bottles of beer on the wall\n" count count newcount]
           [if [> count 2]
               [body [set count [beers newcount]]]
               [body [beer]]]
           [return count]
           ]]

     [void test8 [] [declare] [body
                        [if [equal [sub  [sub 2 1] 1] 0]
                            [body [printf "8. pass Nested expressions work\n"]]
                            [body [printf "8. fail Nested expressions don't work"]]
                        ]]]
     [void test9 [] [declare] [body
                               [printf "Counting down from 10\n"]
                               [beers 9]]]
     
     [int main [int argc  char** argv]
          [declare ;[int a 10]
           ]
          [body
           [test1]
           [test2]
           [test3]
           [test4]
           [test5]
           [test6]
           [test7]
           [test8]
           [test9]
           ;[echo a is a]
           ]]]]]




[let [[nodes [type_program prog]]]
  [pretty-write nodes]
  [display-to-file [go_program  nodes] go_test_filename #:exists 'replace]
  [map system go_test_commands]
  [display-to-file [clang_program nodes] clang_test_filename #:exists 'replace]
  [map system clang_test_commands]
  [display-to-file [bash_program nodes] bash_test_filename #:exists 'replace]
  [map system bash_test_commands]
  ;[display [go_program nodes] ]

  [let [[gout [file->string "results.go"]]
        [cout [file->string "results.c"]]
        [bout [file->string "results.bash"]]
        ]
    [if [and [equal? cout gout][equal? gout bout]]
        [displayln "Job's a good 'un, boss"]
        [displayln "Outputs differ!"]
        ]]
  ]

;Prune all empty leafs from the tree
[define [noEmpty tree]
  [walk tree [lambda [l] [id [filter [lambda [x] [not [void? x]]] [filter id  [filter [lambda [x] [not [empty? x]]] l]]]]]]
  ]

[define nofollow '[ thing1 thing2]]
;Don't recurse through these nodes
[define [noFollow tree]
  [walk tree [lambda [l] [id [filter [lambda [x] [not [member   [first tree] nofollow streq?]]] l]]]]]

[define skipList '[thing3 thing4]]
;Skip over these child nodes
[define [skip tree]
  [walk tree [lambda [l] [id [filter [lambda [x] [not [member   [first tree] skipList streq?]]] l]]]]]


[define [streq? a b] [equal? [format "~a" a] [format "~a" b]]]


[define [traverse tree]
  [if [list? tree]
      [begin
  
        [when [not [empty? tree]]
          [if [not [member   [first tree] nofollow streq?]]
              [filter id [map [lambda [branch]
                                [if  [member branch skipList streq?] false
                                     [traverse branch]]] tree]]
              false
              ]
          ]]
      tree
      ]]
